<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>부산 지하철 역명 맞추기</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
 /* ==========================================================
   Base
   ========================================================== */
html, body, #map { height: 100%; margin: 0; }
body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif;
  overflow: hidden;
}

/* 지도는 무조건 바닥 레이어 */
#map { position: relative; z-index: 0; }

/* ==========================================================
   PC UI (Topbar / Sidebar)
   ========================================================== */
.topbar {
  position: absolute;
  z-index: 10010;
  top: .75rem;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255,255,255,.95);
  border-radius: 14px;
  padding: .5rem .75rem;
  font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif;
  display: flex;
  gap: .5rem;
  align-items: center;
  box-shadow: 0 2px 6px rgba(0,0,0,.06);
  pointer-events: auto;
}
.topbar input {
  border: 1px solid #ccc;
  border-radius: 10px;
  padding: .35rem .5rem;
  font-size: 14px;
  width: 240px;
}

.sidebar {
  position: absolute;
  right: 0;
  top: 0;
  width: 300px;
  height: 100%;
  background: rgba(255,255,255,.98);
  overflow-y: auto;
  z-index: 10000;
  padding: .75rem .75rem 1rem;
  border-left: 1px solid #e5e5e5;
  box-shadow: -4px 0 8px rgba(0,0,0,.04);
  pointer-events: auto;
}
.sidebar h3 { font-size: 15px; margin: 0 0 .5rem 0; }
.line-item {
  display: grid;
  grid-template-columns: 18px 1fr auto;
  align-items: center;
  gap: .5rem;
  padding: .25rem .25rem;
  font-size: 13px;
  border-radius: 8px;
}
.line-item:hover { background: rgba(0,0,0,.035); }
.line-dot { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #ddd; }
.count { font-variant-numeric: tabular-nums; color: #333; }

/* ==========================================================
   Station Marker / Label
   ========================================================== */
.station-icon {
  width: 10px;
  height: 10px;
  border: 1px solid #999;
  background-color: #fff;
  border-radius: 50%;
  box-shadow: 0 0 1px rgba(0,0,0,.4);
}

.label-text {
  background-color: transparent;
  border: none;
  box-shadow: none;
  font-size: 13px;
  font-weight: 800;
  color: #111;
  text-shadow: 0 0 2px #fff, 0 0 4px #fff;
  white-space: nowrap;
}
.leaflet-tooltip-top.label-text::before,
.leaflet-tooltip-bottom.label-text::before,
.leaflet-tooltip-left.label-text::before,
.leaflet-tooltip-right.label-text::before { border: none !important; }

/* Leaflet 캔버스가 터치 먹는 경우 차단(선 클릭 안 쓸 때 추천) */
.leaflet-overlay-pane canvas.leaflet-zoom-animated,
.leaflet-map-pane canvas.leaflet-zoom-animated{
  pointer-events: none !important;
}

/* ==========================================================
   Options Menu (PC+Mobile 공통)
   ========================================================== */
.search-box, .topbar { gap: 8px; }

.options-wrap { position: relative; display: inline-block; }

.options-button, #optionsBtn, #optionsBtnPC {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 38px;
  height: 38px;
  padding: 0;
  border: 1px solid rgba(0,0,0,.15);
  border-radius: 12px;
  background: rgba(255,255,255,.95);
  color: #111;
  font-size: 20px;
  line-height: 1;
  cursor: pointer;
  touch-action: manipulation;
}

.options-menu{
  position: absolute;
  right: 0;
  top: 44px;
  min-width: 190px;
  background: rgba(255,255,255,.98);
  border: 1px solid #e5e5e5;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.12);
  padding: 8px;
  z-index: 20000; /* 메뉴는 해당 UI 안에서 최상단 */
}
.options-item-btn.danger{
  color: #b00020;
  font-weight: 700;
}
.options-item-btn.danger:hover{
  background: rgba(176,0,32,.08);
}
.options-item-btn{
  width: 100%;
  text-align: left;
  padding: 10px 10px;
  border-radius: 10px;
  background: transparent;
  border: 0;
  font-size: 14px;
  color: #111;
  cursor: pointer;
}
.options-item-btn:hover{ background: rgba(0,0,0,.05); }

/* ==========================================================
   Mobile UI
   ========================================================== */
/* PC에서 모바일 UI 숨김 */
.dashboard, .search-box { display: none; }

/* 모바일에서만 표시 + "지도 밖 레이어"로 고정 */
@media (max-width: 768px) {
  .topbar, .sidebar { display: none !important; }

  .dashboard {
    display: block;
    position: fixed;           /* ✅ absolute 금지 */
    top: 0; left: 0; right: 0;
    z-index: 1000000;          /* ✅ map 위 확정 */
    background: rgba(255,255,255,1);
    padding: 10px 10px 5px;
    box-shadow: 0 3px 6px rgba(0,0,0,.1);
    pointer-events: none;      /* ✅ 빈 영역은 터치 통과 */
  }
  .dashboard button, .dashboard input, .dashboard a {
    pointer-events: auto;      /* ✅ 실제 컨트롤만 터치 가능 */
  }

  .completion-rate { margin-bottom: 5px; }
  .rate-number { font-size: 24px; font-weight: 800; color: #333; }
  .rate-text { font-size: 16px; font-weight: 500; color: #555; margin-left: 5px; }

  .line-buttons {
    display: flex;
    flex-direction: column;
    gap: 5px;
    max-height: 200px;
    overflow-y: auto;
    padding-bottom: 5px;
  }
  .line-group { display: flex; flex-wrap: wrap; gap: 8px; }
  .line-button {
    border: none;
    color: white;
    font-weight: 700;
    cursor: pointer;
    text-align: center;
    transition: opacity 0.2s;
    box-shadow: 0 1px 3px rgba(0,0,0,.15);
  }
  .main-lines .line-button {
    width: 38px;
    height: 38px;
    border-radius: 50%;
    font-size: 16px;
    line-height: 38px;
    padding: 0;
  }
  .other-lines .line-button {
    border-radius: 20px;
    font-size: 12px;
    padding: 6px 12px;
    min-width: 60px;
  }

  .search-box {
    display: flex;
    position: fixed;           /* ✅ absolute 금지 */
    left: 15px;
    right: 15px;
    top: 260px;                /* 필요하면 dashboard 높이에 맞게 조절 */
    z-index: 1000001;          /* ✅ dashboard보다 위 */
    background: #fff;
    border-radius: 10px;
    padding: 5px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.25);
    pointer-events: auto;
    transform: none;           /* ✅ stacking 꼬임 방지 */
  }

  .station-input{
    flex: 1;
    min-width: 0;
    border: none;
    padding: 10px 15px;
    font-size: 16px;
    outline: none;
  }
}
</style>
</head>

<body>
  <div id="map"></div>

  <div class="topbar">
    <strong>부산 지하철</strong>
    <input type="text" id="stationSearchPC" placeholder="역 이름을 입력" />

    <div class="options-wrap">
      <button class="options-button" id="optionsBtnPC" type="button" aria-label="옵션">⋮</button>

      <div class="options-menu" id="optionsMenuPC" hidden>
        <button class="options-item-btn" id="toggleAltNameBtnPC" type="button">
          부역명/병기역명 표시
        </button>
			  <button class="options-item-btn danger" id="resetCacheBtnPC" type="button">
    캐시 초기화
  </button>
      </div>
    </div>
  </div>

  <div class="sidebar">
    <h3>노선 목록</h3>
    <div id="lineList"></div>
  </div>

  <div class="dashboard">
    <div class="completion-rate">
      <span class="rate-number" id="totalRate">0.0 %</span>
      <span class="rate-text">역 발견됨</span>
    </div>
    <div class="line-buttons" id="lineButtons"></div>
  </div>

  <div class="search-box">
    <input type="text" id="stationSearchMobile" placeholder="역 이름을 입력" class="station-input" />

    <div class="options-wrap">
      <button class="options-button" id="optionsBtnMobile" type="button" aria-label="옵션">⋮</button>

      <div class="options-menu" id="optionsMenuMobile" hidden>
        <button class="options-item-btn" id="toggleAltNameBtnMobile" type="button">
          부역명/병기역명 표시
        </button>
		        </button>
	  <button class="options-item-btn danger" id="resetCacheBtnMobile" type="button">
    캐시 초기화
  </button>
</div>
      </div>
    </div>
  </div>
</body>



  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>

    // 노선 색상, toCanonicalLine, normStationKey, fetchOverpass, parseData, sortLineEntries, drawLines, nearestLine, computeTotals 함수는 동일하게 유지
    const map = L.map('map', {
    renderer: L.canvas() // 이 한 줄이 랙을 엄청나게 줄여줍니다!
	}).setView([35.1796, 129.0756], 12);
	
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

const bbox = [34.98, 128.78, 35.62, 129.45];
const overpassQuery = `[out:json][timeout:300];
(
	relation["type"="route"]["route"~"^(subway|metro|light_rail|tram|monorail|train|railway|maglev)$"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]})
    ->.routes;

  way(r.routes);


  way["railway"~"^(subway|light_rail|monorail|tram|metro|maglev)$"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  way["railway"~"^(subway|light_rail|monorail|tram|metro|rail|maglev)$"]
    ["service"~"^(subway|metro|urban|commuter|high_speed)$"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  node["railway"~"^(station|halt|tram_stop)$"]["amenity"!="bus_station"]["wikidata"!="Q477420"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  node["public_transport"="stop_position"]
    ["railway"~"^(stop|station|halt|tram_stop|rail)$"]
    ["amenity"!="bus_station"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
	way["railway"~"^(station|halt)$"]["amenity"!="bus_station"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
relation["public_transport"="stop_area"]["amenity"!="bus_station"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
relation["public_transport"="station"]["amenity"!="bus_station"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  relation(17413295) ->.gtxa;
  .gtxa;
);
out geom;`



    const colorMap = {
      "부산 1호선": "#F06A00","부산 2호선": "#81BF48","부산 3호선": "#BB8C00","부산 4호선": "#217DCB", "동해선": "#003DA5", "부산김해경전철":"#8652A1"
    };
	
function toCanonicalLine(raw=""){
      let n = (raw||"").toString().normalize("NFKC");
      // 잡다한 수식어 제거
	    const orig = n; // 셔틀 제거 전 원문 보관
	    if (/(인천국제공항|incheon\s*international\s*airport)/i.test(orig) &&
      /(오렌지\s*셔틀|orange\s*shuttle|셔틀트레인|셔틀\s*트레인|셔틀|shuttle)/i.test(orig)) {
    return ""; // 지도에서 아예 빼기 (원하면 다른 노선명으로 return 해도 됨)
  }
      n = n.replace(/:.*/g, "").replace(/\(.*?\)/g, "").replace(/내선|외선|상행|하행|상선|하선|inbound|outbound/gi, "").replace(/[·\.‧∙・․]/g, "·").replace(/\s+/g, " ").trim();
      n = n.replace(/(성수\s*지선|신설\s*지선|지선)/g, "").replace(/(급행|익스프레스|express)/ig, "").replace(/(셔틀|셔틀트레인|shuttle)/ig, "").replace(/(직통|직통열차|direct)/ig, "").replace(/계통/g, "").replace(/\s+/g, " ").trim();
      n = n.replace(/^수도권 ?전철\s*/g, "").replace(/^서울 ?(지하철|경전철)\s*/g, "").replace(/^인천국제공항철도\s*/g, "공항철도 ").trim();
      
      // [필터링] KTX, SRT, 일반 열차 등은 지도에 안 그리기 위해 빈 값 리턴
      if (/KTX|SRT|새마을|무궁화|누리로|ITX|청춘|가라판|화물|바다열차/.test(n)) return "";
if (/GTX\s*-?\s*A/i.test(n) || /광역급행철도\s*A/i.test(n) || n === "A노선" || n.includes("GTX A")) {
    return "GTX-A";
  }
      if (/^부산 도시철도 1호선/.test(n) || /\b1\s*호선\b/.test(n)) return "부산 1호선";
      if (/^부산 도시철도 2호선/.test(n) || /\b2\s*호선\b/.test(n)) return "부산 2호선";
      if (/^부산 도시철도 3호선/.test(n) || /\b3\s*호선\b/.test(n)) return "부산 3호선"; 
      if (/^부산 도시철도 4호선/.test(n) || /\b4\s*호선\b/.test(n)) return "부산 4호선";

if (/부산\s*[-·]?\s*김해|busan\s*[- ]?\s*gimhae|bgl/i.test(n)) return "부산김해경전철";
      if (/동해선/.test(n)) return "동해선";

    }
// 2) 별칭(병기명/부역명) -> 표준 역명 매핑 (함수 밖에!)
const ALIAS = {
  "남부터미널예술의전당": "남부터미널",
  "구성gtx": "구성",
  // 공백은 norm에서 제거되므로 "구성 gtx"는 사실상 불필요
};

function normStationKey(s = "") {
  // 1) 기본 정규화
  const k = String(s).trim().normalize("NFKC")
    .replace(/[\(\)\[\]{}]/g, "")
    .replace(/\s+/g, "")
    .replace(/[·\.‧∙・․]/g, "·")
    .replace(/역$/, "")
    .toLowerCase();

  // 2) 별칭 적용
  const mapped = ALIAS[k] ?? k;

  // 3) 별칭 결과도 동일 규칙으로 정규화해서 반환(안전)
  return String(mapped).trim().normalize("NFKC")
    .replace(/[\(\)\[\]{}]/g, "")
    .replace(/\s+/g, "")
    .replace(/[·\.‧∙・․]/g, "·")
    .replace(/역$/, "")
    .toLowerCase();
}

	
	// =====================
// Overpass 캐시 (IndexedDB)
// =====================
const OVERPASS_CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 3; // 3일 (원하면 조절)
const OVERPASS_CACHE_DB = "subway-overpass-cache-v1";
const OVERPASS_CACHE_STORE = "kv";

function fnv1a(str) {
  // 짧은 해시(키 길이 줄이기용)
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
  }
  return ("0000000" + h.toString(16)).slice(-8);
}

function openCacheDB() {
  return new Promise((resolve, reject) => {
    if (!("indexedDB" in window)) return reject(new Error("IndexedDB not supported"));
    const req = indexedDB.open(OVERPASS_CACHE_DB, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(OVERPASS_CACHE_STORE)) {
        db.createObjectStore(OVERPASS_CACHE_STORE);
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function cacheGet(key) {
  const db = await openCacheDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OVERPASS_CACHE_STORE, "readonly");
    const store = tx.objectStore(OVERPASS_CACHE_STORE);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => reject(req.error);
    tx.oncomplete = () => db.close();
  });
}

async function cacheSet(key, value) {
  const db = await openCacheDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OVERPASS_CACHE_STORE, "readwrite");
    const store = tx.objectStore(OVERPASS_CACHE_STORE);
    const req = store.put(value, key);
    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
    tx.oncomplete = () => db.close();
  });
}
async function getOverpassWithCache(overpassQuery) {
  const key = `overpass:v8:${fnv1a(overpassQuery)}`; // 네 방식 그대로

  // A) 캐시 읽기: 실패해도 경고만
  try {
    const hit = await cacheGet(key);
    if (hit && hit.data) {
      const obj = (typeof hit.data === "string") ? JSON.parse(hit.data) : hit.data;
      console.log("[Overpass cache] Hit", key);
      return { data: obj, fromCache: true };
    }
    console.log("[Overpass cache] Miss", key);
  } catch (e) {
    console.warn("[Overpass cache] read failed -> no-cache mode", e);
  }
  async function fetchOverpassJSON(url, options) {
  const resp = await fetch(url, options);
  const text = await resp.text();

  if (!resp.ok) {
    console.warn("[Overpass] HTTP", resp.status, text.slice(0, 120));
    throw new Error("Overpass HTTP " + resp.status);
  }

  const t = text.trimStart();
  if (!(t.startsWith("{") || t.startsWith("["))) {
    console.warn("[Overpass] Non-JSON response head:", t.slice(0, 120));
    throw new Error("Overpass returned non-JSON");
  }

  return JSON.parse(text);
}
  // B) fetch: fresh는 여기서만 채운다 (선언을 먼저!)
  let fresh = null;
  try {
    fresh = await fetchOverpass(overpassQuery); // 네 fetch 함수명으로
  } catch (e) {
    console.error("[Overpass] fetch failed", e);
    throw e; // fetch 실패는 진짜 실패니까 올려버리는 게 맞음
  }

  // C) 캐시 저장: fresh가 null이 아닌 상태에서만
  try {
    await cacheSet(key, { savedAt: Date.now(), data: JSON.stringify(fresh) });
    console.log("[Overpass cache] Saved", key);
  } catch (e) {
    console.warn("[Overpass cache] save failed", e);
  }

  return { data: fresh, fromCache: false };
}



// (선택) 콘솔에서 캐시 삭제: await window.clearOverpassCache()
window.clearOverpassCache = async function deleteOverpassDB() {
  return await new Promise((resolve, reject) => {
    const req = indexedDB.deleteDatabase("subway-overpass-cache-v1");

    req.onblocked = () => {
      console.warn("[cache] delete blocked: 다른 탭/연결이 DB를 잡고 있음. 모든 탭을 닫고 다시 시도.");
      // 여기서 사용자에게 안내해도 좋음
    };

    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
  });

};

	
	async function fetchOverpassCached(query, cacheKey, maxAgeHours = 24) {
  const now = Date.now();
  const raw = localStorage.getItem(cacheKey);
  if (raw) {
    try {
      const obj = JSON.parse(raw);
      const ageH = (now - (obj.savedAt || 0)) / 36e5;
      if (obj.data && ageH <= maxAgeHours) {
        console.log("[cache] hit", cacheKey, `age=${ageH.toFixed(2)}h`);
        return obj.data;
      }
    } catch {}
  }

  const data = await fetchOverpass(query); // 기존 함수 그대로 사용
  try {
    localStorage.setItem(cacheKey, JSON.stringify({ savedAt: now, data }));
    console.log("[cache] saved", cacheKey);
  } catch (e) {
    console.warn("[cache] save failed (quota?)", e);
  }
  return data;
}

const ENDPOINTS = [
  "https://overpass-api.de/api/interpreter",
  "https://overpass.private.coffee/api/interpreter",
];

async function fetchOverpass(overpassQuery) {
  const body = "data=" + encodeURIComponent(overpassQuery);

  let lastErr = null;
  for (const url of ENDPOINTS) {
    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
        body,
      });

      const text = await res.text();
      console.log("OVERPASS status:", res.status, "via", url);
      console.log("OVERPASS head:", text.slice(0, 300));

      if (!res.ok) {
        // 504/5xx면 다른 서버로
        lastErr = new Error(`Overpass HTTP ${res.status} via ${url}`);
        if (res.status === 504 || res.status >= 500) continue;
        throw lastErr;
      }
      return JSON.parse(text);
    } catch (e) {
      lastErr = e;
      // CORS로 막히는 서버도 있으니 그땐 다음 엔드포인트로
      continue;
    }
  }
  throw lastErr || new Error("All Overpass endpoints failed.");
}


      const wayMap = new Map();
	
function injectLineFromRelation(elements, relationIds, forcedName, forcedColor, linesArray) {
  const waysById = new Map();
  for (const el of elements) {
    if (el.type === "way" && Array.isArray(el.geometry) && el.geometry.length >= 2) {
      waysById.set(el.id, el.geometry.map(p => [p.lat, p.lon]));
    }
  }

  const relSet = new Set(relationIds);

  const segs = [];
  for (const el of elements) {
    if (el.type === "relation" && relSet.has(el.id) && Array.isArray(el.members)) {
      for (const m of el.members) {
        if (m.type === "way") {
          const g = waysById.get(m.ref);
          if (g && g.length >= 2) segs.push(g);
        }
      }
    }
  }

  if (segs.length === 0) return false;
  linesArray.push({ name: forcedName, color: forcedColor, segs });
  return true;
}
function haversineMeters(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const toRad = x => x * Math.PI / 180;
  const a1 = toRad(lat1), o1 = toRad(lon1);
  const a2 = toRad(lat2), o2 = toRad(lon2);
  const da = a2 - a1, doo = o2 - o1;
  const h =
    Math.sin(da/2)**2 +
    Math.cos(a1)*Math.cos(a2)*Math.sin(doo/2)**2;
  return 2*R*Math.asin(Math.min(1, Math.sqrt(h)));
}
function addStopPointsByNearestStation(lineStops, lineStopPoints, stations) {
  for (const [lineName, pts] of lineStopPoints.entries()) {
    if (!lineStops.has(lineName)) lineStops.set(lineName, new Set());
    const set = lineStops.get(lineName);

    // 공항/대형역은 stop_position ↔ station node가 멀 수 있어 threshold를 좀 크게
    const maxD = (lineName === "공항철도") ? 2000 : 1200;

    for (const [lat, lon] of pts) {
      let bestKey = null, bestD = Infinity;
      for (const st of stations) {
        const d = haversineMeters(lat, lon, st.lat, st.lon);
        if (d < bestD) { bestD = d; bestKey = st.key; }
      }
      if (bestKey && bestD <= maxD) set.add(bestKey);
    }
  }
}



function addManualLineStops(lineStops, rawLineName, stationNames) {
  const lineName = toCanonicalLine(rawLineName) || rawLineName; // ✅ 노선 키 통일
  if (!lineStops.has(lineName)) lineStops.set(lineName, new Set());
  const set = lineStops.get(lineName);

  for (const n of stationNames) {
    const k = normStationKey(n);
    if (k) set.add(k); // ✅ 덮어쓰기 X, 계속 추가
  }
}

function parseData(data) {
  const elements = data.elements || [];

  const wayMap = new Map();
  const lineMap = new Map();
  const rawStations = [];
  const nodeMap = new Map();
const relMap = new Map();
for (const el of elements) {
  if (el.type === "node") nodeMap.set(el.id, el);
  else if (el.type === "relation") relMap.set(el.id, el);
}

  const usedWayIds = new Set();
  function distMeters(a, b) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const lat1 = toRad(a.lat), lon1 = toRad(a.lon);
    const lat2 = toRad(b.lat), lon2 = toRad(b.lon);
    const dlat = lat2 - lat1;
    const dlon = lon2 - lon1;
    const h =
      Math.sin(dlat / 2) ** 2 +
      Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) ** 2;
    return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
  }
  // 1) 선로 좌표 수집
const wayInfoMap = new Map(); // id -> { seg, tags }

for (const el of elements) {
  if (el.type === "way" && Array.isArray(el.geometry)) {
    const seg = el.geometry.map(p => [p.lat, p.lon]);
    wayMap.set(el.id, seg);
    wayInfoMap.set(el.id, { seg, tags: el.tags || {} });
  }
}

  // 2) 노선(Relation) 처리
  const lineStops = new Map(); // lineName -> Set(stationKey)
  const lineStopPoints = new Map(); // lineName -> Array<[lat, lon]> (이름 없는 stop_position 등)
  for (const el of elements) {
    const t = el.tags || {};
    const r = (t.route || "");

    if (el.type === "relation" && t.type === "route" &&
        /^(subway|metro|light_rail|tram|monorail|train|railway|maglev)$/.test(r)) {

      const raw = t["name:ko"] || t.name || t.ref || "";
      const name = toCanonicalLine(raw);
      if (!name) continue;

      const color = colorMap[name] || t.colour || t.color || "#003DA5";
      if (!lineMap.has(name)) lineMap.set(name, { name, color, segs: [] });

if (Array.isArray(el.members)) {
  for (const m of el.members) {
    // 선로
if (m.type === "way" && wayInfoMap.has(m.ref)) {
  const info = wayInfoMap.get(m.ref);
  const svc = (info.tags.service || "").toLowerCase();

  // ✅ 차량기지/측선/유치선/분기선 등은 노선도에서 제외
  if (/(yard|siding|spur|stabling|crossover)/.test(svc)) continue;

  lineMap.get(name).segs.push(info.seg);
  usedWayIds.add(m.ref);
  continue;
}

    // ✅ 정차역(stop/platform 등) 수집: 이름 없으면 좌표로 저장
    const role = (m.role || "").toLowerCase();
    const isStopLike =
      role.includes("stop") ||
      role.includes("platform") ||
      role.includes("stop_entry_only") ||
      role.includes("stop_exit_only");

    if (isStopLike && m.type === "node") {
      const nEl = nodeMap.get(m.ref);
      if (!nEl) continue;
      const nt = nEl.tags || {};
      const n = nt["name:ko"] || nt.name || "";

      if (n) {
        const key = normStationKey(n);
        if (!lineStops.has(name)) lineStops.set(name, new Set());
        lineStops.get(name).add(key);
      } else {
        if (!lineStopPoints.has(name)) lineStopPoints.set(name, []);
        lineStopPoints.get(name).push([nEl.lat, nEl.lon]); // 이름 없는 stop_position 대비
      }
    }

    // stop_area가 멤버로 들어오는 경우(이름만으로도 key 추가 가능)
    if (isStopLike && m.type === "relation") {
      const rEl = relMap.get(m.ref);
      if (!rEl) continue;
      const rt = rEl.tags || {};
      const n = rt["name:ko"] || rt.name || "";
      if (!n) continue;

      const key = normStationKey(n);
      if (!lineStops.has(name)) lineStops.set(name, new Set());
      lineStops.get(name).add(key);
    }
  }
}


    }

    // 2-1) 역 정보 수집 (node)
    if (el.type === "node" && (t.railway === "station" || t.public_transport === "station")) {
      const n = t["name:ko"] || t.name || "";
      if (n && n !== "원릉") rawStations.push({ name: n, key: normStationKey(n), lat: el.lat, lon: el.lon });
    }

    // 2-2) 역 정보 수집 (way: station, out center 필요)
    if (el.type === "way" && t.railway === "station" && el.center) {
      const n = t["name:ko"] || t.name || "";
    }

    // 2-3) 역 정보 수집 (relation: stop_area/station, out center 필요)
if (el.type === "relation" && t.public_transport === "stop_area" && el.center) {
  const n = t["name:ko"] || t.name || "";

}

  }

  // 3) 왕따 선로 구제
  for (const el of elements) {
    if (el.type === "way" && wayMap.has(el.id) && !usedWayIds.has(el.id)) {
      const t = el.tags || {};
      const isRailway = /^(subway|light_rail|metro|monorail|rail|train)$/.test(t.railway || "");
      if (!isRailway) continue;

      const raw = t["name:ko"] || t.name || t.ref || "";
      const name = toCanonicalLine(raw);
      if (name && lineMap.has(name)) {
        lineMap.get(name).segs.push(wayMap.get(el.id));
        usedWayIds.add(el.id);
      }
	  const svc = (t.service || "").toLowerCase();
if (/(yard|siding|spur|stabling|crossover)/.test(svc)) continue;
    }
  }

  const linesArray = Array.from(lineMap.values());


  // 4) 역 필터링 + 중복 제거 (환승역 병합)
// ===== 역 병합(클러스터링) =====


const THRESH_M = 450; // 필요시 600~800까지 올려보기

// 1) 선로 근처 필터 통과한 후보만 모으기
// 1) 선로 근처 필터 통과한 후보만 모으기 (안전 버전)
const candidates = [];
let sawAnyPointGlobal = false;

for (const s of rawStations) {
  let minD2 = Infinity;
  let sawPoint = false;

  if (linesArray.length > 0) {
    for (const Ln of linesArray) {
      // ⚠️ 여기서 GTX-A를 빼지 마. parseData는 "전체 역 목록"이 목적이라서 부작용 큼.
      for (const seg of Ln.segs) {
        if (!Array.isArray(seg) || seg.length === 0) continue;
        for (const p of seg) {
          sawPoint = true;
          sawAnyPointGlobal = true;
          const d2 = (s.lat - p[0]) ** 2 + (s.lon - p[1]) ** 2;
          if (d2 < minD2) minD2 = d2;
        }
      }
    }
  }

  // ✅ 선로 점을 한 번도 못 봤으면 필터 적용하지 않음 (자동역 몰살 방지)
  if (linesArray.length !== 0 && sawAnyPointGlobal && sawPoint && minD2 >= 0.0005) continue;

  candidates.push({ ...s });
}


// 2) key별로 묶기
const groups = new Map();
for (const s of candidates) {
  const k = s.key;
  if (!groups.has(k)) groups.set(k, []);
  groups.get(k).push(s);
}

// 3) 각 key 그룹에서 거리 기준 클러스터링 → 클러스터마다 1개로 압축
const dedup = [];
for (const [key, arr] of groups.entries()) {
  if (arr.length === 1) {
    dedup.push(arr[0]);
    continue;
  }

  const used = new Array(arr.length).fill(false);

  for (let i = 0; i < arr.length; i++) {
    if (used[i]) continue;
    used[i] = true;

    const q = [i];
    const comp = [arr[i]];

    while (q.length) {
      const u = q.pop();
      for (let v = 0; v < arr.length; v++) {
        if (used[v]) continue;
        if (distMeters(arr[u], arr[v]) <= THRESH_M) {
          used[v] = true;
          q.push(v);
          comp.push(arr[v]);
        }
      }
    }

    let lat = 0, lon = 0;
    for (const s of comp) { lat += s.lat; lon += s.lon; }
    lat /= comp.length; lon /= comp.length;

    dedup.push({ ...comp[0], key, lat, lon });
  }
}

function mergeManualStations(base, manual) {
  const out = base.slice();         // ✅ base는 전부 유지
  const TH_M = 300;                 // manual 좌표와 300m 이내면 "그 역"으로 간주(필요시 조절)

  for (const m of (manual || [])) {
    let bestIdx = -1;
    let bestD = Infinity;

    for (let i = 0; i < out.length; i++) {
      const s = out[i];
      if (s.key !== m.key) continue;              // 같은 '역명 key' 후보만 비교
      const d = haversineMeters(s.lat, s.lon, m.lat, m.lon);
      if (d < bestD) { bestD = d; bestIdx = i; }
    }

    if (bestIdx >= 0 && bestD <= TH_M) {
      // ✅ 가장 가까운 1개만 manual로 보정(덮어쓰기)
      out[bestIdx] = { ...out[bestIdx], ...m, _manual: true };
    } else {
      // ✅ 근처에 같은 이름 역이 없으면 새로 추가
      out.push({ ...m, _manual: true });
    }
  }

  return out;
}


const manualStations = [
];

const dedup2 = mergeManualStations(dedup, manualStations);
addStopPointsByNearestStation(lineStops, lineStopPoints, dedup2);

const stationsFinal = mergeManualStations(dedup, manualStations);
// DEBUG: 같은 역 이름이 여러 개로 남아있는지 체크
const m = new Map();
for (const s of dedup2) {
  const base = (s.key || "").split("#")[0];
  if (!m.has(base)) m.set(base, []);
  m.get(base).push(s);
}
const dups = [...m.entries()].filter(([k, arr]) => arr.length >= 2);
console.log("DUP STATIONS:", dups.map(([k, arr]) => ({
  key: k,
  n: arr.length,
  pts: arr.map(x => [x.lat, x.lon])
})));

const lineStopsObj = Object.fromEntries(
  [...lineStops.entries()].map(([k, v]) => [k, [...v]])
);
const EXCLUDED_STATION_NAMES = [

];
const EXCLUDED_STATION_KEYS = new Set(EXCLUDED_STATION_NAMES.map(normStationKey));
const filteredStations = dedup2.filter(s => !EXCLUDED_STATION_KEYS.has(s.key));

return { lines: linesArray, stations: dedup2, lineStops: lineStopsObj };

}


function pickStationsForLine(lineName, allStations, lineSegs, manualByLine) {
  const allow = new Set((manualByLine?.[lineName] || []).map(x => x.key));

  const THRESH_M = 300; // 이건 보조
  const out = [];

  for (const st of allStations) {
    // 1) 화이트리스트가 있으면 그것만 통과
    if (allow.size > 0 && !allow.has(st.key)) continue;

    // 2) (보조) 선로 근접 체크
    if (distanceToLineMeters(st, lineSegs) <= THRESH_M) out.push(st);
  }
  return out;
}
    function sortLineEntries(entries){
      function keyFor(name){const m=name.match(/^(\d+)호선$/);if(m)return{type:'num',val:parseInt(m[1],10)};return{type:'txt',val:name};}
      return entries.sort(([aName],[bName])=>{const A=keyFor(aName),B=keyFor(bName);if(A.type!==B.type)return A.type==='num'?-1:1;if(A.type==='num')return A.val-B.val;return aName.localeCompare(bName,'ko');});
    }

function drawBaseMarkers(stations) {
  const excludeKeys = new Set();

  const baseIcon = L.divIcon({
    className: 'base-station-marker',
    html: `<div class='station-icon'></div>`,
    iconSize: [12, 12],
    iconAnchor: [6, 6]
  });

  stations.forEach(s => {
    if (excludeKeys.has(s.key)) return; // ✅ 여기서 컷
    L.marker([s.lat, s.lon], {
      icon: baseIcon,
      zIndexOffset: 100
    }).addTo(map);
  });
}
    let subwayData={lines:[],stations:[]};
	const SETTINGS_KEY = "subway:v8:hideAltName";
let hideAltName = (localStorage.getItem(SETTINGS_KEY) === "1");
    const shownStations=new Map();
    let totalStationsCount = 0;
    let matchedStationsCount = 0;
	
	const PROGRESS_KEY = "metro_progress_v1";
let foundStationIds = new Set(); // stationId 문자열 집합

function makeStationId(st){
  return `${st.key}@${st.lat.toFixed(6)},${st.lon.toFixed(6)}`;
}

function loadProgress(){
  try{
    const raw = localStorage.getItem(PROGRESS_KEY);
    if (!raw) return;
    const arr = JSON.parse(raw);
    if (Array.isArray(arr)) foundStationIds = new Set(arr);
  }catch(e){
    console.warn("[progress] load failed", e);
  }
}

function saveProgress(){
  try{
    localStorage.setItem(PROGRESS_KEY, JSON.stringify([...foundStationIds]));
  }catch(e){
    console.warn("[progress] save failed", e);
  }
}
window.lineStats = window.lineStats || {};

// lineStops(노선별 정차역 key 목록) 기준으로 matched 재계산
function recomputeMatchedFromProgress(){
  const d = window.subwayData;
  if (!d || !d.lineStops) return;

  // 발견한 역들의 key 집합
  const foundKeys = new Set();
  for (const id of foundStationIds){
    const k = (id.split("@")[0] || "").trim();
    if (k) foundKeys.add(k);
  }

  // lineStops 기준으로 노선별 matched 재계산
  for (const [lineName, keys] of Object.entries(d.lineStops || {})) {
    const arr = Array.isArray(keys) ? keys : [];
    let m = 0;
    for (const k of arr) if (foundKeys.has(k)) m++;

    lineStats[lineName] = lineStats[lineName] || { total: 0, matched: 0, color: colorMap[lineName] || "#003DA5" };
    lineStats[lineName].matched = m;
  }

  // lineStops에 없는 잔재 제거(안전)
  for (const k of Object.keys(lineStats)) {
    if (!(k in (d.lineStops || {}))) delete lineStats[k];
  }
}

    function drawLines(lines){
      lines.forEach(Ln=>{
        lineStats[Ln.name]=lineStats[Ln.name]||{total:0,matched:0,color:Ln.color};
        Ln.segs.forEach(seg=>{if(Array.isArray(seg)&&seg.length)L.polyline(seg,{color:Ln.color,weight:6,opacity:0.95,lineCap:'round'}).addTo(map);});
      });
    }
	const STATION_LINE_OVERRIDE = new Map([

]);
	function nearestLine(lat, lon) {
		let best = { d2: Infinity, color: '#003DA5', name: null };
		  
		  // 데이터가 아직 안 불러와졌으면 기본값 뱉고 튑니다.
		  if (!subwayData || !subwayData.lines) return best;

		  for (const Ln of subwayData.lines) {
			for (const seg of Ln.segs) {
			  for (const p of seg) {
				const d2 = (lat - p[0]) ** 2 + (lon - p[1]) ** 2;
				if (d2 < best.d2) {
				  best = { d2, color: Ln.color, name: Ln.name };
				}
			  }
			}
		  }
		  return best;
}
function nearestLineForStation(station){
  const ov = STATION_LINE_OVERRIDE.get(station.key);
  if (ov?.primary) return ov.primary; // 문자열로 반환
  return nearestLine(station.lat, station.lon).name; // 기존 거리 기반
}
function computeTotals() {
  const data = window.subwayData;
  if (!data) return;

  const ls = data.lineStops || {};

  // total 세팅
  for (const lineName of Object.keys(ls)) {
    const arr = ls[lineName] || [];
    lineStats[lineName] = lineStats[lineName] || { total: 0, matched: 0, color: colorMap[lineName] || "#003DA5" };
    lineStats[lineName].total = arr.length;
    lineStats[lineName].color = colorMap[lineName] || lineStats[lineName].color || "#003DA5";
    if (typeof lineStats[lineName].matched !== "number") lineStats[lineName].matched = 0;
  }

  // lineStops에 없는 잔재 제거
  for (const k of Object.keys(lineStats)) {
    if (!(k in ls)) delete lineStats[k];
  }
  const uniq = new Set();
Object.values(window.subwayData.lineStops || {}).forEach(arr => arr.forEach(k => uniq.add(k)));
totalStationsCount = uniq.size;
}


    /* ------------------------------------------------ */
    /* PC 환경: 사이드바 업데이트 함수 (기존 로직) */
    /* ------------------------------------------------ */
    function updateSidebar(){
      const container=document.getElementById('lineList');
      container.innerHTML='';
      const entries=sortLineEntries(Object.entries(lineStats));
      entries.forEach(([name,s])=>{
        const div=document.createElement('div');
        div.className='line-item';
        // PC 사이드바에서는 발견 역 개수를 표시합니다.
        div.innerHTML=`<div class='line-dot' style='background:${s.color}'></div><div>${name}</div><div class='count'>${s.matched} / ${s.total}</div>`;
        container.appendChild(div);
      });
    }
    
	const MAX_DISTANCE_SQ = 0.000002; // 0.002 * 0.002 = 0.000004 (경위도 제곱 거리)

    function getNearbyLines(lat, lon) {
        const nearbyLines = new Set();
        subwayData.lines.forEach(Ln => {
            let isNearby = false;
            // 노선의 모든 선분(Segments)을 확인합니다.
            for (const seg of Ln.segs) {
                // 선분의 모든 점을 확인합니다.
                for (const p of seg) {
                    const d2 = (lat - p[0]) ** 2 + (lon - p[1]) ** 2;
                    if (d2 < MAX_DISTANCE_SQ) {
                        nearbyLines.add(Ln.name); // 근처에 있으면 해당 노선 이름 추가
                        isNearby = true;
                        break; // 해당 노선은 찾았으니 다음 노선으로 넘어감
                    }
                }
                if (isNearby) break;
            }
        });
        return Array.from(nearbyLines);
    }
function nearbyLinesForStation(station){
  const ov = STATION_LINE_OVERRIDE.get(station.key);
  if (!ov) return getNearbyLines(station.lat, station.lon);

  // primary는 무조건 포함, also는 추가
  const base = new Set(getNearbyLines(station.lat, station.lon));
  base.add(ov.primary);
  (ov.also || []).forEach(x => base.add(x));
  return [...base];
}
    /* ------------------------------------------------ */
    /* 모바일 환경: 대시보드 업데이트 함수 (새로운 로직) */
    /* ------------------------------------------------ */
    function updateDashboard(){
      const container=document.getElementById('lineButtons');
      if (!container) return; // 요소가 없으면(PC 환경이면) 실행하지 않음

      container.innerHTML='';

      // 1. 전체 발견율 계산 및 업데이트
      matchedStationsCount = 0;
      Object.values(lineStats).forEach(s => { matchedStationsCount += s.matched; });

      const totalRateElement = document.getElementById('totalRate');
      const rate = totalStationsCount > 0 ? (matchedStationsCount / totalStationsCount) * 100 : 0;
      if (totalRateElement) totalRateElement.textContent = `${rate.toFixed(1)} %`;

      // 2. 노선 버튼 그룹 생성 (모바일용)
      const entries=sortLineEntries(Object.entries(lineStats));

      const mainLinesDiv = document.createElement('div');
      mainLinesDiv.className = 'line-group main-lines';

      const otherLinesDiv = document.createElement('div');
      otherLinesDiv.className = 'line-group other-lines';

      entries.forEach(([name,s])=>{
        const btn=document.createElement('button');
        btn.className='line-button';
        btn.style.backgroundColor=s.color;

        const isMainLine = name.match(/^(\d+)호선$/) && parseInt(name.match(/^(\d+)호선$/)[1]) <= 9;
        
        if (isMainLine) {
            btn.textContent = name.replace('호선', '');
            mainLinesDiv.appendChild(btn);
        } else {
            btn.textContent = name; 
            otherLinesDiv.appendChild(btn);
        }
      });
      
      container.appendChild(mainLinesDiv);
      container.appendChild(otherLinesDiv);
    }

    /* ------------------------------------------------ */
    /* 통합 업데이트 함수 (환경에 따라 호출) */
    /* ------------------------------------------------ */
function updateUI(){
  if (window.innerWidth <= 768) updateDashboard();
  else updateSidebar();
}
function linesForStationKey(stKey) {
  const data = window.subwayData;
  const out = [];
  const stops = data?.lineStops || {};
  for (const [lineName, keys] of Object.entries(stops)) {
    if (keys.includes(stKey)) out.push(lineName);
  }
  return out;
}
async function tryPersistStorage() {
  if (!navigator.storage || !navigator.storage.persist) return;
  const persisted = await navigator.storage.persisted();
  if (!persisted) {
    const ok = await navigator.storage.persist();
    console.log("[storage] persist request:", ok);
  } else {
    console.log("[storage] already persisted");
  }
}
function fillLineStopsByProximityFor(lineName, maxD2 = 0.000004) {
  const d = window.subwayData;
  if (!d?.lines || !d?.stations || !d?.lineStops) return;

  const Ln = d.lines.find(x => x.name === lineName);
  if (!Ln) { console.warn("[fill] no such line:", lineName); return; }

  const set = new Set(d.lineStops[lineName] || []);
  for (const st of d.stations) {
    let best = Infinity;
    for (const seg of (Ln.segs || [])) {
      if (!Array.isArray(seg)) continue;
      for (const p of seg) {
        const d2 = (st.lat - p[0])**2 + (st.lon - p[1])**2;
        if (d2 < best) best = d2;
      }
    }
    if (best < maxD2) set.add(st.key);
  }
  d.lineStops[lineName] = [...set];
  console.log("[fill lineStops]", lineName, "=>", d.lineStops[lineName].length);
}

    async function init(){
	await tryPersistStorage();
      try{
	  // ✅ 노선도/검색 결과에서 완전히 제외할 역들 (월미바다열차)
function excludeStationsEverywhere(names) {
  const keys = new Set();
    const excludeKeys = new Set(names.map(normStationKey));
  for (const nm of names) keys.add(normStationKey(nm));

  // 1) 검색 대상(=stations)에서 제거
  window.subwayData.stations = (window.subwayData.stations || []).filter(s => !keys.has(s.key));

  // 2) lineStops(노선별 정차역 목록)에서도 제거 → total/카운트 꼬임 방지
  const ls = window.subwayData.lineStops || {};
  for (const lineName of Object.keys(ls)) {
    ls[lineName] = (ls[lineName] || []).filter(k => !keys.has(k));
  }
  window.subwayData.lineStops = ls;
}
const CACHE_KEY = "overpass:v8:" + bbox.join(","); // bbox 바뀌면 키도 바뀜
const { data: raw } = await getOverpassWithCache(overpassQuery);
window.rawOverpass = raw;
console.log("elements:", raw.elements.length);

// ✅ parseData는 한 번만
subwayData = window.subwayData = parseData(raw);
loadProgress();
recomputeMatchedFromProgress();

// ✅ 삭제할 역 이름은 '배열'로 따로 둔다
const EXCLUDED_NAMES = ["청사포", "다릿돌 전망대"]; 
const excludeKeys = new Set(EXCLUDED_NAMES.map(normStationKey));

// 1) stations(검색/결과)에서 제거
window.subwayData.stations = (window.subwayData.stations || []).filter(
  s => !excludeKeys.has(s.key)
);

// 2) lineStops(노선 총역수/카운트용)에서도 제거
const ls = window.subwayData.lineStops || {};
for (const lineName of Object.keys(ls)) {
  ls[lineName] = (ls[lineName] || []).filter(k => !excludeKeys.has(k));
}
window.subwayData.lineStops = ls;

// 전역 변수도 같은 객체로
subwayData = window.subwayData;

console.log("Parsed Data:", subwayData);

if (subwayData.lines.length === 0) {
  console.warn("노선 데이터가 없심더! BBox나 쿼리를 확인해보이소.");
}

drawLines(subwayData.lines);
fillLineStopsByProximityFor("부산김해경전철", 0.000006); // 김해경전철은 살짝 넉넉하게
// 필요하면 동해선도 같이:
// fillLineStopsByProximityFor("동해선", 0.000006);

computeTotals();
computeTotals();
recomputeMatchedFromProgress();
drawBaseMarkers(subwayData.stations);
restoreFoundMarkersFromProgress();
updateUI();

// bounds도 동일하게
const bounds = L.latLngBounds([]);
subwayData.lines.forEach(Ln => Ln.segs.forEach(seg => seg.forEach(p => bounds.extend(p))));
if (bounds.isValid()) map.fitBounds(bounds.pad(0.05));
subwayData.lines.forEach(Ln=>Ln.segs.forEach(seg=>seg.forEach(p=>bounds.extend(p)))); 
if(bounds.isValid())map.fitBounds(bounds.pad(0.05)); }
catch(e){alert('초기화 오류: '+e.message);console.error(e);} }

    // ********* 검색 입력 처리 로직 수정 *********
    const inputPC = document.getElementById('stationSearchPC');
    const inputMobile = document.getElementById('stationSearchMobile');
function pickClosestLineNameForStation(st, lineNames) {
  const data = window.subwayData;
  if (!data || !Array.isArray(data.lines) || !lineNames || lineNames.length === 0) return null;

  let bestName = null;
  let bestD2 = Infinity;

  for (const name of lineNames) {
    const Ln = data.lines.find(L => L.name === name);
    if (!Ln) continue;

    for (const seg of (Ln.segs || [])) {
      if (!Array.isArray(seg)) continue;
      for (const p of seg) {
        const d2 = (st.lat - p[0]) ** 2 + (st.lon - p[1]) ** 2;
        if (d2 < bestD2) {
          bestD2 = d2;
          bestName = name;
        }
      }
    }
  }
  return bestName;
}

function linesForStationResolved(st) {
  // 1) key기반(충돌 가능)
  const byKey = linesForStationKey(st.key);

  // 2) 좌표 기반(충돌에 강함)
  const byGeo = nearbyLinesForStation(st);

  // 둘 다 있으면 교집합 우선(동명이역 분리)
  if (byKey.length && byGeo.length) {
    const setGeo = new Set(byGeo);
    const inter = byKey.filter(x => setGeo.has(x));
    if (inter.length) return inter;
  }

  // 하나만 있으면 그걸 사용
  if (byGeo.length) return byGeo;
  if (byKey.length) return byKey;

  // 최후 수단
  const one = nearestLineForStation(st);
  return one ? [one] : [];
}
//병기역명, 부역명 리스트
window.MANUAL_ALIAS = new Map([
//1호선
  [normStationKey("몰운대"), normStationKey("다대포해수욕장")],
  [normStationKey("연제"), normStationKey("시청")],
  [normStationKey("아트몰링"), normStationKey("하단")],
  [normStationKey("사하구청"), normStationKey("당리")],
  [normStationKey("삼육부산병원"), normStationKey("서대신")],
  [normStationKey("해동병원"), normStationKey("남포")],
  [normStationKey("해양수산부.동구청"), normStationKey("부산진")],
  [normStationKey("이샘병원"), normStationKey("범내골")],
  [normStationKey("청맥병원"), normStationKey("서면")],
  [normStationKey("부산시민공원.송상현광장"), normStationKey("부전")],
  [normStationKey("(주)소셜빈"), normStationKey("양정역")],
  [normStationKey("한국건강관리협회"), normStationKey("동래")],
  [normStationKey("우리들병원"), normStationKey("온천장")],
  [normStationKey("종합버스터미널"), normStationKey("노포")],
//2호선/
  [normStationKey("시립미술관"), normStationKey("벡스코")],
  [normStationKey("범어"), normStationKey("남양산")],
  [normStationKey("해운대백병원"), normStationKey("장산")],
  [normStationKey("해운대부민병원"), normStationKey("해운대")],
  [normStationKey("벡스코.법무법인 대륜"), normStationKey("센텀시티")],
  [normStationKey("박원욱병원"), normStationKey("광안")],
  [normStationKey("KBS.수영구청"), normStationKey("남천")],
  [normStationKey("동명대학교"), normStationKey("경성대.부경대")],
  [normStationKey("부산고려병원"), normStationKey("대연")],
  [normStationKey("남구청"), normStationKey("못골")],
  [normStationKey("연세미래IFC의원 부설검진센터"), normStationKey("국제금융센터.부산은행")],
  [normStationKey("온 종합병원"), normStationKey("부암")],
  [normStationKey("인제대학교 부산백병원"), normStationKey("개금")],
  [normStationKey("사상구청.한국건강관리협회"), normStationKey("감전")],
  [normStationKey("부산도서관"), normStationKey("덕포")],
  [normStationKey("방송통신대"), normStationKey("수정")],
  [normStationKey("더퍼스트 피부과의원"), normStationKey("화명")],
  [normStationKey("시청"), normStationKey("양산")],
//3호선/
  [normStationKey("병무청"), normStationKey("망미")],
  [normStationKey("법원.검찰청"), normStationKey("거제")],
  [normStationKey("광혜병원"), normStationKey("미남")],
  [normStationKey("부산폴리텍대학"), normStationKey("남산정")],
  [normStationKey("부민병원"), normStationKey("숙등")],
//4호선
  [normStationKey("동래읍성임진왜란역사관.힘찬병원"), normStationKey("수안")],
  [normStationKey("안락.부산항운병원"), normStationKey("충렬사")],
  [normStationKey("세웅병원"), normStationKey("서동")],
  [normStationKey("아랫반송"), normStationKey("영산대")],
  [normStationKey("고촌주택단지"), normStationKey("안평")],
//부산김해경전철
  [normStationKey("서부터미널"), normStationKey("사상")],
  [normStationKey("강변공원"), normStationKey("괘법르네시떼")],
  [normStationKey("금호마을"), normStationKey("서부산유통지구")],
  [normStationKey("활천"), normStationKey("인제대")],
  [normStationKey("김해여객터미널"), normStationKey("봉황")],
  [normStationKey("화정"), normStationKey("장신대")],
  [normStationKey("삼계"), normStationKey("가야대")],
  [normStationKey("최안과의원"), normStationKey("부원")],
  [normStationKey("김해보건소"), normStationKey("수로왕릉")],
//동해선 광역전철
  [normStationKey("원자력병원"), normStationKey("좌천")],
  [normStationKey("간절곶"), normStationKey("서생")],  
]);
function escapehtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}
function getAltNameForStation(st){
  // 프로젝트마다 다르니, 너가 실제로 쓰는 필드명으로 1개만 남기면 됨.
  return st.altName || st.alias || st._aliasText || st.oneAliasKey || "";
}

function buildStationLabelHTML(st){
  const alt = st._altText || "";
  if (!alt || hideAltName) return escapehtml(st.name);
  // 줄바꿈 표기(Leaflet tooltip은 HTML을 그대로 렌더링함)
  return `<div style="text-align:center;">${escapehtml(st.name)}</div><span class="alt-name">(${escapehtml(alt)})</span>`;
}
function refreshAllLabels(){
  for (const v of shownStations.values()){
    if (v.tooltip && v.st) v.tooltip.setContent(buildStationLabelHTML(v.st));
  }
}

function applyManualAlias(userText) {
  const k = normStationKey((userText || "").replace(/\./g,'·'));
  return window.MANUAL_ALIAS.get(k) || k;
}
function addFoundStationMarker(st, aliasKeyForThisInput = "") {
  const data = window.subwayData;
  if (!data) return;

  const stationId = makeStationId(st);
  if (shownStations.has(stationId)) return; // 이미 그려져있으면 스킵

  // 연결 노선 계산
  let connectingLines = linesForStationResolved(st);
  const primaryName = pickClosestLineNameForStation(st, connectingLines);
  const primaryObj = primaryName ? data.lines.find(L => L.name === primaryName) : null;

  const fallbackNearest = nearestLine(st.lat, st.lon);
  const markerColor = primaryObj?.color || colorMap[primaryName] || fallbackNearest.color;

  const icon = L.divIcon({
    className: '',
    html: `<div class='station-icon' style='background-color:${markerColor}; border: 2px solid #fff; width:14px; height:14px;'></div>`,
    iconSize: [14, 14],
    iconAnchor: [7, 7]
  });

  const marker = L.marker([st.lat, st.lon], { icon, zIndexOffset: 1000 }).addTo(map);

  // 리로드 복원은 “사용자 입력 별칭”이 없으니 alt는 보통 빈 값
  st._altText = aliasKeyForThisInput || st._altText || "";

  const tooltip = L.tooltip({ permanent: true, direction: 'top', className: 'label-text' })
    .setLatLng([st.lat, st.lon])
    .setContent(buildStationLabelHTML(st))
    .addTo(map);

  shownStations.set(stationId, { marker, tooltip, st });
}

// 리로드 시 progress(foundStationIds)로 마커/라벨 복원
function restoreFoundMarkersFromProgress() {
  const data = window.subwayData;
  if (!data?.stations || !foundStationIds?.size) return;

  // stations를 stationId로 빠르게 찾기 위한 인덱스
  const byId = new Map();
  for (const st of data.stations) byId.set(makeStationId(st), st);

  let restored = 0;
  for (const id of foundStationIds) {
    const st = byId.get(id);
    if (!st) continue; // 데이터가 바뀌었거나(Overpass/병합 변경) 좌표가 달라졌을 수 있음
    addFoundStationMarker(st, ""); // 별칭 없음
    restored++;
  }
  console.log("[restore] found markers:", restored, "/", foundStationIds.size);

  refreshAllLabels();
}

const searchHandler = (e, inputElement) => {
  if (e.key !== 'Enter') return;

  const data = window.subwayData;
  if (!data || !Array.isArray(data.stations)) {
    alert("데이터가 아직 로드되지 않았습니다.");
    return;
  }

const userTextRaw = (inputElement.value || "").trim();
const userKey = normStationKey(userTextRaw.replace(/\./g,'·')); // 사용자가 친 걸 정규화
const key = applyManualAlias(userTextRaw);                      // 대표역 key로 resolve
if (!key) return;

function buildReverseAliasMap(aliasMap) {
  const rev = new Map(); // canonicalKey -> Set(aliasText)
  for (const [aliasKey, canonicalKey] of aliasMap.entries()) {
    if (!rev.has(canonicalKey)) rev.set(canonicalKey, new Set());
    // aliasKey는 정규화 key라 예쁘게 보이진 않으니, "표시용 문자열"을 따로 넣고 싶으면 아래 방법 2가 더 좋음
    rev.get(canonicalKey).add(aliasKey);
  }
  return rev;
}


const foundList = data.stations.filter(s => normStationKey(s.key || s.name || "") === key);
  if (foundList.length === 0) {
    alert("정확히 일치하는 역명을 찾을 수 없습니다.");
    return;
  }

  const center = map.getCenter();

  const targets = foundList
    .filter(s => typeof s.lat !== 'undefined' && s.lat !== null)
    .map(s => ({ s, d2: (s.lat - center.lat)**2 + (s.lon - center.lng)**2 }))
    .sort((a, b) => a.d2 - b.d2)
    .map(x => x.s);

  if (targets.length === 0) return;

  for (const st of targets) {
  // ✅ 사용자가 별칭으로 입력한 경우에만 병기 표기
  const REVERSE_ALIAS = buildReverseAliasMap(window.MANUAL_ALIAS);

const aliases = REVERSE_ALIAS.get(st.key);
const oneAliasKey = aliases ? [...aliases][0] : "";
const label = oneAliasKey ? `<div style="text-align:center;">${st.name}</div>(${escapehtml(oneAliasKey)})` : st.name;

const stationId = `${st.key}@${st.lat.toFixed(6)},${st.lon.toFixed(6)}`;
if (shownStations.has(stationId)) continue;	
const firstTime = !foundStationIds.has(stationId);
foundStationIds.add(stationId);
if (firstTime) saveProgress();
	let connectingLines = linesForStationResolved(st);

// primary(색상용) 라인은 “후보 중 실제로 가장 가까운 노선”
const primaryName = pickClosestLineNameForStation(st, connectingLines);

// primary 라인 색을 우선 사용, 없으면 기존 nearestLine
const primaryObj = primaryName ? data.lines.find(L => L.name === primaryName) : null;
const fallbackNearest = nearestLine(st.lat, st.lon);
const markerColor = primaryObj?.color || colorMap[primaryName] || fallbackNearest.color;

// 아이콘에 markerColor 적용
const icon = L.divIcon({
  className: '',
  html: `<div class='station-icon' style='background-color:${markerColor}; border: 2px solid #fff; width:14px; height:14px;'></div>`,
  iconSize: [14, 14],
  iconAnchor: [7, 7]
});


    const marker = L.marker([st.lat, st.lon], { icon, zIndexOffset: 1000 }).addTo(map);
	st._altText = oneAliasKey || "";   // ✅ 토글용으로 저장

const tooltip = L.tooltip({ permanent: true, direction: 'top', className: 'label-text' })
  .setLatLng([st.lat, st.lon])
  .setContent(buildStationLabelHTML(st))
  .addTo(map);
shownStations.set(stationId, { marker, tooltip, st });

if (connectingLines.length === 0) {
  connectingLines = nearbyLinesForStation(st); // 이미 만들어둔 함수
}

// ✅ 그래도 없으면 최후: nearest 1개만
if (connectingLines.length === 0) {
  const one = nearestLineForStation(st);
  if (one) connectingLines = [one];
}

// (선택) 디버그: 어떤 역이 lineStops에 없었는지 로그
if (!linesForStationKey(st.key).length) {
  console.warn("[lineStops miss]", st.name, st.key, "fallback:", connectingLines);
}


}
recomputeMatchedFromProgress();

if (window.innerWidth <= 768) updateDashboard();
else updateSidebar();

  inputElement.value = '';
  map.panTo([targets[0].lat, targets[0].lon]);
};
    if (inputPC) inputPC.addEventListener('keypress', e => searchHandler(e, inputPC));
    if (inputMobile) inputMobile.addEventListener('keypress', e => searchHandler(e, inputMobile));
    
    // 화면 크기 변경 시 UI 업데이트 (PC-모바일 전환 시)
    window.addEventListener('resize', updateUI);

    init();



function setMenuText(btn){
  if (!btn) return;
  btn.textContent = hideAltName ? "부역명/병기역명 표시" : "부역명/병기역명 숨기기";
}

function bindOptionsMenu(btnId, menuId, toggleBtnId) {
  const btn = document.getElementById(btnId);
  const menu = document.getElementById(menuId);
  const toggleBtn = document.getElementById(toggleBtnId);
  if (!btn || !menu || !toggleBtn) return;

  setMenuText(toggleBtn);

  const close = () => { menu.hidden = true; };

  const openOrClose = (e) => {
    e.preventDefault();
    e.stopPropagation();
    menu.hidden = !menu.hidden;
  };

  // ✅ 모바일에서 확실히: touchstart + click 둘 다
  btn.addEventListener("touchstart", openOrClose, { passive: false });
  btn.addEventListener("click", openOrClose);

  menu.addEventListener("click", (e) => e.stopPropagation());
  document.addEventListener("click", close);

  toggleBtn.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    hideAltName = !hideAltName;
    localStorage.setItem(SETTINGS_KEY, hideAltName ? "1" : "0");
    setMenuText(toggleBtn);
    refreshAllLabels();     // ✅ 실시간 반영
    close();
  });
}
async function clearAllOverpassCaches() {
  // 1) IndexedDB 캐시(DB 통째 삭제)
  try {
    if (typeof window.clearOverpassCache === "function") {
      await window.clearOverpassCache();
    } else { await (async function deleteOverpassDB() {
    return await new Promise((resolve, reject) => {
      const req = indexedDB.deleteDatabase("subway-overpass-cache-v1");
      req.onblocked = () => console.warn("[cache] delete blocked");
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  })();
    }
  } catch (e) {
    console.warn("[cache] indexeddb clear failed", e);
  }

  // 2) localStorage에 남은 캐시(있으면) 제거
  try {
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const k = localStorage.key(i);
      if (!k) continue;
      // 네가 쓰는 패턴들: "overpass:v8:..." / "overpass:v8:bbox..." 등
if (k.startsWith("overpass:")) keysToRemove.push(k);
    }
    keysToRemove.forEach(k => localStorage.removeItem(k));
  } catch (e) {
    console.warn("[cache] localStorage clear failed", e);
  }
}
async function clearIDBStore(dbName, storeName) {
  return await new Promise((resolve, reject) => {
    const openReq = indexedDB.open(dbName);
    openReq.onerror = () => reject(openReq.error);

    openReq.onsuccess = () => {
      const db = openReq.result;

      if (!db.objectStoreNames.contains(storeName)) {
        db.close();
        resolve({ ok: false, reason: "store_not_found" });
        return;
      }

      const tx = db.transaction(storeName, "readwrite");
      const store = tx.objectStore(storeName);
      const req = store.clear();

      req.onerror = () => reject(req.error);
      tx.oncomplete = () => { db.close(); resolve({ ok: true }); };
      tx.onerror = () => { db.close(); reject(tx.error); };
    };
  });
}

function clearLocalStorageOverpassKeys() {
  const rm = [];
  for (let i = 0; i < localStorage.length; i++) {
    const k = localStorage.key(i);
    if (!k) continue;
    if (k.startsWith("overpass:") || k.startsWith("overpass:v8:")) rm.push(k);
  }
  rm.forEach(k => localStorage.removeItem(k));
  console.log("[localStorage] removed:", rm.length, rm.slice(0, 5));
  return rm.length;
}

async function resetOverpassCacheHard() {
  // 1) IndexedDB DB 통째 삭제 (가장 확실)
  await window.clearOverpassCache(); // deleteDatabase 사용

  // 2) localStorage 키 제거
  clearLocalStorageOverpassKeys();
}

function bindResetCacheButton(btnId, menuId) {
  const btn = document.getElementById(btnId);
  const menu = document.getElementById(menuId);
  if (!btn) return;

  const handler = async (e) => {
    e.preventDefault();
    e.stopPropagation();

    const ok = confirm("Overpass 캐시를 삭제하고 새로고침할까요?");
    if (!ok) return;

    btn.disabled = true;
    btn.textContent = "초기화 중...";

await resetOverpassCacheHard();
location.reload();
    // 메뉴 닫기
    if (menu) menu.hidden = true;
await resetOverpassCacheHard();
  localStorage.removeItem(PROGRESS_KEY);
    // 새로고침(캐시 삭제 후 다시 받아오게)
    location.reload();
  };

  // ✅ 모바일 확실히: touchstart + click 둘 다
  btn.addEventListener("touchstart", handler, { passive: false });
  btn.addEventListener("click", handler);
}

bindResetCacheButton("resetCacheBtnPC", "optionsMenuPC");
bindResetCacheButton("resetCacheBtnMobile", "optionsMenuMobile");

bindOptionsMenu("optionsBtnPC", "optionsMenuPC", "toggleAltNameBtnPC");
bindOptionsMenu("optionsBtnMobile", "optionsMenuMobile", "toggleAltNameBtnMobile");

  </script>
</body>
</html>
