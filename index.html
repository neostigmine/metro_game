<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>수도권 지하철 (반응형 v8)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    /* ========================================================== */
    /* 1. PC 기본 스타일 (원본 파일의 스타일 유지) */
    /* ========================================================== */
    html, body, #map { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif; overflow: hidden; }

    /* PC용 Topbar (지도 상단 중앙 검색창) */
    .topbar { 
      position: absolute; z-index: 1001; top: .75rem; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,.95); border-radius: 14px; padding: .5rem .75rem;
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif;
      display: flex; gap: .5rem; align-items: center; box-shadow: 0 2px 6px rgba(0,0,0,.06); 
    }
    .topbar input { border: 1px solid #ccc; border-radius: 10px; padding: .35rem .5rem; font-size: 14px; width: 240px; }

    /* PC용 Sidebar (우측 노선 목록) */
    .sidebar { 
      position: absolute; right: 0; top: 0; width: 300px; height: 100%;
      background: rgba(255,255,255,.98); overflow-y: auto; z-index: 1000;
      font-family: system-ui, -apple-system, 'Noto Sans KR', sans-serif;
      padding: .75rem .75rem 1rem; border-left: 1px solid #e5e5e5;
      box-shadow: -4px 0 8px rgba(0,0,0,.04); 
    }
    .sidebar h3 { font-size: 15px; margin: 0 0 .5rem 0; }
    .line-item { display: grid; grid-template-columns: 18px 1fr auto; align-items: center; gap: .5rem; padding: .25rem .25rem; font-size: 13px; border-radius: 8px; }
    .line-item:hover { background: rgba(0,0,0,.035); }
    .line-dot { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #ddd; }
    .count { font-variant-numeric: tabular-nums; color: #333; }
    
    /* 공통 스타일 유지 */
	.station-icon { 
    /* (수정) 기본 마커는 흰색으로 통일하고, 테두리(border)를 회색으로 설정 */
     width: 10px;        /* 마커 크기 축소 */
     height: 10px;       /* 마커 크기 축소 */
     border: 1px solid #999; /* 밝은 회색 테두리 */
     background-color: #fff; /* 배경색은 흰색 */
     border-radius: 50%; 
     box-shadow: 0 0 1px rgba(0,0,0,.4); /* 그림자 약하게 */
	}
	.label-text {background-color: transparent; border: none; box-shadow: none; font-size: 13px; font-weight: 800; color: #111; text-shadow: 0 0 2px #fff, 0 0 4px #fff; white-space: nowrap;}    
	.label-text {background-color: transparent; border: none; box-shadow: none; font-size: 13px; font-weight: 800; color: #111; text-shadow: 0 0 2px #fff, 0 0 4px #fff; white-space: nowrap;}
	.leaflet-tooltip-top.label-text::before,
	.leaflet-tooltip-bottom.label-text::before,
	.leaflet-tooltip-left.label-text::before,
	.leaflet-tooltip-right.label-text::before {
		border: none !important;
	}
    /* ========================================================== */
    /* 2. 모바일 스타일 (Media Query: 화면 너비 768px 이하) */
    /* ========================================================== */
    @media (max-width: 768px) {
      /* PC용 요소 숨김 (또는 위치 변경) */
      .topbar { display: none !important; } /* PC용 상단 중앙 검색창 숨김 */
      .sidebar { display: none !important; } /* PC용 우측 노선 목록 숨김 */

      /* 모바일용 상단 대시보드 */
      .dashboard {
        position: absolute; top: 0; left: 0; right: 0; z-index: 1001;
        background: rgba(255,255,255,1); 
        padding: 10px 10px 5px;
        box-shadow: 0 3px 6px rgba(0,0,0,.1);
      }
      .completion-rate { margin-bottom: 5px; }
      .rate-number { font-size: 24px; font-weight: 800; color: #333; }
      .rate-text { font-size: 16px; font-weight: 500; color: #555; margin-left: 5px; }

      /* 모바일 노선 버튼 */
      .line-buttons {
        display: flex; flex-direction: column; gap: 5px;
        max-height: 200px; overflow-y: auto; padding-bottom: 5px;
      }
      .line-group {
        display: flex; flex-wrap: wrap; gap: 8px;
      }
      .line-button {
        border: none; color: white; font-weight: 700; cursor: pointer; text-align: center;
        transition: opacity 0.2s;
        box-shadow: 0 1px 3px rgba(0,0,0,.15);
      }
      .main-lines .line-button {
        width: 38px; height: 38px; border-radius: 50%;
        font-size: 16px; line-height: 38px; padding: 0;
      }
      .other-lines .line-button {
        border-radius: 20px; font-size: 12px; padding: 6px 12px; min-width: 60px;
      }
      
      /* 모바일용 검색창 (대시보드 아래) */
      .search-box {
          position: absolute;
          top: 260px; /* **이 값은 모바일 대시보드의 예상 높이(약 170~200px)에 맞춰 조정** */
          left: 15px;
          right: 15px;
          display: flex; /* Flex로 변경 */
          background-color: white;
          border-radius: 10px;
          padding: 5px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.25);
          z-index: 10003; 
      }
      .station-input {
          flex: 1; border: none; padding: 10px 15px; font-size: 16px; outline: none;
      }
      .options-button {
          background: none; border: none; font-size: 20px; padding: 0 10px; color: #888; cursor: pointer;
      }
    }
    
    /* 기본적으로 모바일 UI는 숨김 처리 (PC에서 보이지 않도록) */
    .dashboard, .search-box {
        display: none; 
    }
    /* 단, 모바일 뷰에서는 보이도록 설정 */
    @media (max-width: 768px) {
        .dashboard, .search-box {
            display: block; /* 모바일에서 다시 보이게 함 */
        }
        /* search-box는 flex로 설정해야 내부 요소가 정렬됨 */
        .search-box {
            display: flex;
        }
    }

  </style>
</head>
<body>
  <div id="map"></div>

  <div class="topbar">
    <strong>수도권 지하철</strong>
    <input type="text" id="stationSearchPC" placeholder="역 이름을 입력" />
  </div>
  
  <div class="sidebar">
    <h3>노선 목록</h3>
    <div id="lineList"></div>
  </div>

  <div class="dashboard">
    <div class="completion-rate">
        <span class="rate-number" id="totalRate">0.0 %</span>
        <span class="rate-text">역 발견됨</span>
    </div>
    <div class="line-buttons" id="lineButtons">
        </div>
  </div>

  <div class="search-box">
    <input type="text" id="stationSearchMobile" placeholder="역 이름을 입력" class="station-input" />
    <button class="options-button">⋮</button>
  </div>


  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
	const MANUAL_STATIONS = [
  {
    id: "manual:gyeonggang:chowol",
    name: "초월",
    line: "경강선",
    lat: 37.37,
    lon: 127.29,
  },
];
    // 노선 색상, toCanonicalLine, normStationKey, fetchOverpass, parseData, sortLineEntries, drawLines, nearestLine, computeTotals 함수는 동일하게 유지
    const map = L.map('map', {
    renderer: L.canvas() // 이 한 줄이 랙을 엄청나게 줄여줍니다!
	}).setView([37.56, 126.98], 11);
	
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

	const bbox = [36.7, 126.4, 38.3, 127.9];
const overpassQuery = `[out:json][timeout:300];
(
	relation["type"="route"]["route"~"^(subway|metro|light_rail|tram|monorail|train|railway|maglev)$"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]})
    ->.routes;

  way(r.routes);


  way["railway"~"^(subway|light_rail|monorail|tram|metro|maglev)$"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  way["railway"~"^(subway|light_rail|monorail|tram|metro|rail|maglev)$"]
    ["service"~"^(subway|metro|urban|commuter|high_speed)$"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  node["railway"~"^(station|halt|tram_stop)$"]["amenity"!="bus_station"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  node["public_transport"="stop_position"]
    ["railway"~"^(stop|station|halt|tram_stop|rail)$"]
    ["amenity"!="bus_station"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
	way["railway"~"^(station|halt)$"]["amenity"!="bus_station"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
relation["public_transport"="stop_area"]["amenity"!="bus_station"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
relation["public_transport"="station"]["amenity"!="bus_station"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  relation(17413295) ->.gtxa;
  .gtxa;
);
out geom;`



    const colorMap = {
      "1호선": "#0052A4","2호선": "#00A84D","3호선": "#EF7C1E","4호선": "#00A2D1","5호선": "#A664A3",
      "6호선": "#9E4510","7호선": "#5D6519","8호선": "#D6406A","9호선": "#8E764B",
      "수인·분당선": "#E0A134","경의·중앙선": "#2ABFD0","공항철도": "#006D9D","신분당선": "#BB1834",
      "경강선": "#003DA5","경춘선": "#0C8E72","서해선": "#81A914",
      "김포골드라인": "#A17800","의정부경전철": "#FDA600","용인경전철": "#509F22","우이신설선": "#B0CE18",
      "신림선": "#6789CA","인천1호선": "#6E98BB","인천2호선": "#ED8B00", "GTX-A":"#9A6292", "인천공항자기부상열차": "#FFD400",
    };
	
function toCanonicalLine(raw=""){
      let n = (raw||"").toString().normalize("NFKC");
      // 잡다한 수식어 제거
	    const orig = n; // 셔틀 제거 전 원문 보관
	    if (/(인천국제공항|incheon\s*international\s*airport)/i.test(orig) &&
      /(오렌지\s*셔틀|orange\s*shuttle|셔틀트레인|셔틀\s*트레인|셔틀|shuttle)/i.test(orig)) {
    return ""; // 지도에서 아예 빼기 (원하면 다른 노선명으로 return 해도 됨)
  }
      n = n.replace(/:.*/g, "").replace(/\(.*?\)/g, "").replace(/내선|외선|상행|하행|상선|하선|inbound|outbound/gi, "").replace(/[·\.‧∙・․]/g, "·").replace(/\s+/g, " ").trim();
      n = n.replace(/(성수\s*지선|신설\s*지선|지선)/g, "").replace(/(급행|익스프레스|express)/ig, "").replace(/(셔틀|셔틀트레인|shuttle)/ig, "").replace(/(직통|직통열차|direct)/ig, "").replace(/계통/g, "").replace(/\s+/g, " ").trim();
      n = n.replace(/^수도권 ?전철\s*/g, "").replace(/^서울 ?(지하철|경전철)\s*/g, "").replace(/^인천국제공항철도\s*/g, "공항철도 ").trim();
      
      // [필터링] KTX, SRT, 일반 열차 등은 지도에 안 그리기 위해 빈 값 리턴
      if (/KTX|SRT|새마을|무궁화|누리로|ITX|청춘|가라판|화물|바다열차/.test(n)) return "";
if (/GTX\s*-?\s*A/i.test(n) || /광역급행철도\s*A/i.test(n) || n === "A노선" || n.includes("GTX A")) {
    return "GTX-A";
  }   if (/^신분당선/.test(n)) return "신분당선";
      if (/^1호선/.test(n) || /\b1\s*호선\b/.test(n) || /^(경인선|경원선|장항선)/.test(n)) return "1호선";
      if (/^2호선/.test(n) || /\b2\s*호선\b/.test(n)) return "2호선";
      // [핵심] 일산선 잡아서 3호선으로 편입
      if (/^3호선/.test(n) || /\b3\s*호선\b/.test(n) || /일산선/.test(n)) return "3호선"; 
      if (/^4호선/.test(n) || /\b4\s*호선\b/.test(n) || /^(과천선|안산선)/.test(n)) return "4호선";
      if (/^5호선/.test(n) || /\b5\s*호선\b/.test(n)) return "5호선";
      if (/^6호선/.test(n) || /\b6\s*호선\b/.test(n)) return "6호선";
      if (/^7호선/.test(n) || /\b7\s*호선\b/.test(n)) return "7호선";
      if (/^8호선/.test(n) || /\b8\s*호선\b/.test(n)) return "8호선";
      if (/^9호선/.test(n) || /\b9\s*호선\b/.test(n)) return "9호선";

      if (/^(수인.?분당선|분당선|수인선)$/.test(n)) return "수인·분당선";
      if (/(경의.?중앙선|경의선|중앙선)/.test(n)) return "경의·중앙선";
      if (/인천국제공항|AREX|공항철도/i.test(n)) return "공항철도";
      if (/경춘선/.test(n)) return "경춘선";
      if (/경강선/.test(n)) return "경강선";
      if (/서해선/.test(n)) return "서해선";
      if (/김포/.test(n)) return "김포골드라인";
      if (/의정부/.test(n)) return "의정부경전철";
      if (/용인|에버라인/.test(n)) return "용인경전철";
      if (/우이신설/.test(n)) return "우이신설선";
      if (/신림/.test(n)) return "신림선";
      if (/인천.?1호선|인천 도시철도 1호선/.test(n)) return "인천1호선";
      if (/인천.?2호선|인천 도시철도 2호선/.test(n)) return "인천2호선";
// GTX-A 인식 로직 강화
  if (/GTX\s*-?\s*A/i.test(n) || /수도권\s?광역급행철도\s?A/i.test(n)) return "GTX-A";
  // 위 목록에 없으면(예: KTX 노선명 등) 그리지 않음
    if (/(인천\s*공항\s*자기\s*부상|인천공항\s*자기부상|인천공항\s*자기부상철도|Incheon\s*Airport\s*Maglev|Incheon\s*Maglev)/i.test(n))
    return "인천공항자기부상열차";

      return "";
    }
    function normStationKey(s=""){
      return s.trim().normalize('NFKC').replace(/[\(\)\[\]{}]/g,'').replace(/\s+/g,'').replace(/[·\.‧∙・․]/g,'·').replace(/역$/,'').toLowerCase();
    }

const PROGRESS_KEY = "subway-progress:v1";

function saveProgress() {
  try {
    const payload = {
      savedAt: Date.now(),
      shown: Array.from(shownStations.keys()), // stationId 문자열들
      matchedByLine: Object.fromEntries(
        Object.entries(lineStats).map(([k, v]) => [k, v.matched || 0])
      ),
    };
    localStorage.setItem(PROGRESS_KEY, JSON.stringify(payload));
    console.log("[progress] saved");
  } catch (e) {
    console.warn("[progress] save failed", e?.name, e?.message, e);
  }
}

function restoreProgress() {
  try {
    const raw = localStorage.getItem(PROGRESS_KEY);
    if (!raw) { console.log("[progress] none"); return; }
    const obj = JSON.parse(raw);

    // lineStats matched 복원
    if (obj.matchedByLine) {
      for (const [k, m] of Object.entries(obj.matchedByLine)) {
        if (!lineStats[k]) lineStats[k] = { total: 0, matched: 0, color: colorMap[k] || "#003DA5" };
        lineStats[k].matched = Number(m) || 0;
      }
    }

    // 찍힌 역들(마커/라벨) 복원
    const ids = Array.isArray(obj.shown) ? obj.shown : [];
    for (const stationId of ids) {
      if (shownStations.has(stationId)) continue;

      // stationId 형식: `${st.key}@${lat},${lon}`
      const m = stationId.match(/^(.+?)@(-?\d+(?:\.\d+)?),(-?\d+(?:\.\d+)?)$/);
      if (!m) continue;

      const key = m[1];
      const lat = parseFloat(m[2]);
      const lon = parseFloat(m[3]);

      // 이름 찾기(같은 key 여러 개면 좌표로 가장 가까운 것)
      const cands = (window.subwayData?.stations || []).filter(s => s.key === key);
      let best = null, bestD2 = Infinity;
      for (const s of cands) {
        const d2 = (s.lat - lat) ** 2 + (s.lon - lon) ** 2;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
      if (!best) continue;

      // 색상 계산(네 기존 로직 재사용)
      let connectingLines = linesForStationResolved(best);
      const primaryName = pickClosestLineNameForStation(best, connectingLines);
      const primaryObj = primaryName ? window.subwayData.lines.find(L => L.name === primaryName) : null;
      const fallbackNearest = nearestLine(best.lat, best.lon);
      const markerColor = primaryObj?.color || colorMap[primaryName] || fallbackNearest.color;

      const icon = L.divIcon({
        className: '',
        html: `<div class='station-icon' style='background-color:${markerColor}; border: 2px solid #fff; width:14px; height:14px;'></div>`,
        iconSize: [14, 14],
        iconAnchor: [7, 7]
      });

      const marker = L.marker([best.lat, best.lon], { icon, zIndexOffset: 1000 }).addTo(map);
      L.tooltip({ permanent: true, direction: 'top', className: 'label-text' })
        .setLatLng([best.lat, best.lon])
        .setContent(best.name)
        .addTo(map);

      shownStations.set(stationId, marker);
    }

    console.log("[progress] restored", ids.length);
  } catch (e) {
    console.warn("[progress] restore failed", e?.name, e?.message, e);
  }
}

// (선택) 진행 초기화
window.clearProgress = () => localStorage.removeItem(PROGRESS_KEY);

	  
	// =====================
// Overpass 캐시 (IndexedDB)
// =====================
const OVERPASS_CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 3; // 3일 (원하면 조절)
const OVERPASS_CACHE_DB = "subway-overpass-cache-v1";
const OVERPASS_CACHE_STORE = "kv";

function fnv1a(str) {
  // 짧은 해시(키 길이 줄이기용)
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
  }
  return ("0000000" + h.toString(16)).slice(-8);
}

function openCacheDB() {
  return new Promise((resolve, reject) => {
    if (!("indexedDB" in window)) return reject(new Error("IndexedDB not supported"));
    const req = indexedDB.open(OVERPASS_CACHE_DB, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(OVERPASS_CACHE_STORE)) {
        db.createObjectStore(OVERPASS_CACHE_STORE);
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function cacheGet(key) {
  const db = await openCacheDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OVERPASS_CACHE_STORE, "readonly");
    const store = tx.objectStore(OVERPASS_CACHE_STORE);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => reject(req.error);
    tx.oncomplete = () => db.close();
  });
}

async function cacheSet(key, value) {
  const db = await openCacheDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OVERPASS_CACHE_STORE, "readwrite");
    const store = tx.objectStore(OVERPASS_CACHE_STORE);
    const req = store.put(value, key);
    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
    tx.oncomplete = () => db.close();
  });
}

async function getOverpassWithCache(query, opts = {}) {
  const { forceNetwork = false, cacheKey = null } = opts;

  // ✅ 쿼리 문자열을 정규화해서 키 안정화 (해시 쓰더라도 안정적)
  const qNorm = (query || "").toString().normalize("NFKC").replace(/\s+/g, " ").trim();

  const key = cacheKey
    ? `overpass:${cacheKey}`
    : `overpass:${fnv1a(qNorm)}`;

  console.log("[Overpass cache] key =", key);

  if (!forceNetwork) {
    try {
      const hit = await cacheGet(key);
      if (hit && hit.data) {
        console.log("[Overpass cache] HIT", hit.savedAt ? new Date(hit.savedAt).toISOString() : "");
        return { data: hit.data, fromCache: true };
      }
      console.log("[Overpass cache] MISS");
    } catch (e) {
      console.warn("[Overpass cache] read failed", e?.name, e?.message, e);
    }
  }

  const fresh = await fetchOverpass(query);

  try {
    await cacheSet(key, { savedAt: Date.now(), data: fresh });
    console.log("[Overpass cache] SAVED");
  } catch (e) {
    console.warn("[Overpass cache] save failed", e?.name, e?.message, e);
  }

  return { data: fresh, fromCache: false };
}



// (선택) 콘솔에서 캐시 삭제: await window.clearOverpassCache()
window.clearOverpassCache = async () => {
  return new Promise((resolve, reject) => {
    const req = indexedDB.deleteDatabase(OVERPASS_CACHE_DB);
    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
  });
};

	
	async function fetchOverpassCached(query, cacheKey, maxAgeHours = 24) {
  const now = Date.now();
  const raw = localStorage.getItem(cacheKey);
  if (raw) {
    try {
      const obj = JSON.parse(raw);
      const ageH = (now - (obj.savedAt || 0)) / 36e5;
      if (obj.data && ageH <= maxAgeHours) {
        console.log("[cache] hit", cacheKey, `age=${ageH.toFixed(2)}h`);
        return obj.data;
      }
    } catch {}
  }

  const data = await fetchOverpass(query); // 기존 함수 그대로 사용
  try {
    localStorage.setItem(cacheKey, JSON.stringify({ savedAt: now, data }));
    console.log("[cache] saved", cacheKey);
  } catch (e) {
    console.warn("[cache] save failed (quota?)", e);
  }
  return data;
}

const ENDPOINTS = [
  "https://overpass-api.de/api/interpreter",
  "https://overpass.private.coffee/api/interpreter",
];

async function fetchOverpass(overpassQuery) {
  const body = "data=" + encodeURIComponent(overpassQuery);

  let lastErr = null;
  for (const url of ENDPOINTS) {
    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
        body,
      });

      const text = await res.text();
      console.log("OVERPASS status:", res.status, "via", url);
      console.log("OVERPASS head:", text.slice(0, 300));

      if (!res.ok) {
        // 504/5xx면 다른 서버로
        lastErr = new Error(`Overpass HTTP ${res.status} via ${url}`);
        if (res.status === 504 || res.status >= 500) continue;
        throw lastErr;
      }
      return JSON.parse(text);
    } catch (e) {
      lastErr = e;
      // CORS로 막히는 서버도 있으니 그땐 다음 엔드포인트로
      continue;
    }
  }
  throw lastErr || new Error("All Overpass endpoints failed.");
}


      const wayMap = new Map();
	
function injectLineFromRelation(elements, relationIds, forcedName, forcedColor, linesArray) {
  const waysById = new Map();
  for (const el of elements) {
    if (el.type === "way" && Array.isArray(el.geometry) && el.geometry.length >= 2) {
      waysById.set(el.id, el.geometry.map(p => [p.lat, p.lon]));
    }
  }

  const relSet = new Set(relationIds);

  const segs = [];
  for (const el of elements) {
    if (el.type === "relation" && relSet.has(el.id) && Array.isArray(el.members)) {
      for (const m of el.members) {
        if (m.type === "way") {
          const g = waysById.get(m.ref);
          if (g && g.length >= 2) segs.push(g);
        }
      }
    }
  }

  if (segs.length === 0) return false;
  linesArray.push({ name: forcedName, color: forcedColor, segs });
  return true;
}
function haversineMeters(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const toRad = x => x * Math.PI / 180;
  const a1 = toRad(lat1), o1 = toRad(lon1);
  const a2 = toRad(lat2), o2 = toRad(lon2);
  const da = a2 - a1, doo = o2 - o1;
  const h =
    Math.sin(da/2)**2 +
    Math.cos(a1)*Math.cos(a2)*Math.sin(doo/2)**2;
  return 2*R*Math.asin(Math.min(1, Math.sqrt(h)));
}
function addStopPointsByNearestStation(lineStops, lineStopPoints, stations) {
  for (const [lineName, pts] of lineStopPoints.entries()) {
    if (!lineStops.has(lineName)) lineStops.set(lineName, new Set());
    const set = lineStops.get(lineName);

    // 공항/대형역은 stop_position ↔ station node가 멀 수 있어 threshold를 좀 크게
    const maxD = (lineName === "공항철도") ? 2000 : 1200;

    for (const [lat, lon] of pts) {
      let bestKey = null, bestD = Infinity;
      for (const st of stations) {
        const d = haversineMeters(lat, lon, st.lat, st.lon);
        if (d < bestD) { bestD = d; bestKey = st.key; }
      }
      if (bestKey && bestD <= maxD) set.add(bestKey);
    }
  }
}



function addManualLineStops(lineStops, lineName, stationNames) {
  if (!lineStops.has(lineName)) lineStops.set(lineName, new Set());
  const set = lineStops.get(lineName);

  for (const nm of stationNames) {
    set.add(normStationKey(nm));
  }
}
function parseData(data) {
  const elements = data.elements || [];

  const wayMap = new Map();
  const lineMap = new Map();
  const rawStations = [];
  const nodeMap = new Map();
const relMap = new Map();
for (const el of elements) {
  if (el.type === "node") nodeMap.set(el.id, el);
  else if (el.type === "relation") relMap.set(el.id, el);
}

  const usedWayIds = new Set();
  function distMeters(a, b) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const lat1 = toRad(a.lat), lon1 = toRad(a.lon);
    const lat2 = toRad(b.lat), lon2 = toRad(b.lon);
    const dlat = lat2 - lat1;
    const dlon = lon2 - lon1;
    const h =
      Math.sin(dlat / 2) ** 2 +
      Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) ** 2;
    return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
  }
  // 1) 선로 좌표 수집
const wayInfoMap = new Map(); // id -> { seg, tags }

for (const el of elements) {
  if (el.type === "way" && Array.isArray(el.geometry)) {
    const seg = el.geometry.map(p => [p.lat, p.lon]);
    wayMap.set(el.id, seg);
    wayInfoMap.set(el.id, { seg, tags: el.tags || {} });
  }
}

  // 2) 노선(Relation) 처리
  const lineStops = new Map(); // lineName -> Set(stationKey)
  const lineStopPoints = new Map(); // lineName -> Array<[lat, lon]> (이름 없는 stop_position 등)
  for (const el of elements) {
    const t = el.tags || {};
    const r = (t.route || "");

    if (el.type === "relation" && t.type === "route" &&
        /^(subway|metro|light_rail|tram|monorail|train|railway|maglev)$/.test(r)) {

      const raw = t["name:ko"] || t.name || t.ref || "";
      const name = toCanonicalLine(raw);
      if (!name) continue;

      const color = colorMap[name] || t.colour || t.color || "#003DA5";
      if (!lineMap.has(name)) lineMap.set(name, { name, color, segs: [] });

if (Array.isArray(el.members)) {
  for (const m of el.members) {
    // 선로
if (m.type === "way" && wayInfoMap.has(m.ref)) {
  const info = wayInfoMap.get(m.ref);
  const svc = (info.tags.service || "").toLowerCase();

  // ✅ 차량기지/측선/유치선/분기선 등은 노선도에서 제외
  if (/(yard|siding|spur|stabling|crossover)/.test(svc)) continue;

  lineMap.get(name).segs.push(info.seg);
  usedWayIds.add(m.ref);
  continue;
}

    // ✅ 정차역(stop/platform 등) 수집: 이름 없으면 좌표로 저장
    const role = (m.role || "").toLowerCase();
    const isStopLike =
      role.includes("stop") ||
      role.includes("platform") ||
      role.includes("stop_entry_only") ||
      role.includes("stop_exit_only");

    if (isStopLike && m.type === "node") {
      const nEl = nodeMap.get(m.ref);
      if (!nEl) continue;
      const nt = nEl.tags || {};
      const n = nt["name:ko"] || nt.name || "";

      if (n) {
        const key = normStationKey(n);
        if (!lineStops.has(name)) lineStops.set(name, new Set());
        lineStops.get(name).add(key);
      } else {
        if (!lineStopPoints.has(name)) lineStopPoints.set(name, []);
        lineStopPoints.get(name).push([nEl.lat, nEl.lon]); // 이름 없는 stop_position 대비
      }
    }

    // stop_area가 멤버로 들어오는 경우(이름만으로도 key 추가 가능)
    if (isStopLike && m.type === "relation") {
      const rEl = relMap.get(m.ref);
      if (!rEl) continue;
      const rt = rEl.tags || {};
      const n = rt["name:ko"] || rt.name || "";
      if (!n) continue;

      const key = normStationKey(n);
      if (!lineStops.has(name)) lineStops.set(name, new Set());
      lineStops.get(name).add(key);
    }
  }
}


    }

    // 2-1) 역 정보 수집 (node)
    if (el.type === "node" && (t.railway === "station" || t.public_transport === "station")) {
      const n = t["name:ko"] || t.name || "";
      if (n && n !== "원릉") rawStations.push({ name: n, key: normStationKey(n), lat: el.lat, lon: el.lon });
    }

    // 2-2) 역 정보 수집 (way: station, out center 필요)
    if (el.type === "way" && t.railway === "station" && el.center) {
      const n = t["name:ko"] || t.name || "";
      if (n && n !== "원릉") rawStations.push({ name: n, key: normStationKey(n), lat: el.center.lat, lon: el.center.lon });
    }

    // 2-3) 역 정보 수집 (relation: stop_area/station, out center 필요)
if (el.type === "relation" && t.public_transport === "stop_area" && el.center) {
  const n = t["name:ko"] || t.name || "";
  if (n && n !== "원릉") {
    rawStations.push({ name: n, key: normStationKey(n), lat: el.center.lat, lon: el.center.lon, _stop_area: true });
  }
}

  }

  // 3) 왕따 선로 구제
  for (const el of elements) {
    if (el.type === "way" && wayMap.has(el.id) && !usedWayIds.has(el.id)) {
      const t = el.tags || {};
      const isRailway = /^(subway|light_rail|metro|monorail|rail|train)$/.test(t.railway || "");
      if (!isRailway) continue;

      const raw = t["name:ko"] || t.name || t.ref || "";
      const name = toCanonicalLine(raw);
      if (name && lineMap.has(name)) {
        lineMap.get(name).segs.push(wayMap.get(el.id));
        usedWayIds.add(el.id);
      }
	  const svc = (t.service || "").toLowerCase();
if (/(yard|siding|spur|stabling|crossover)/.test(svc)) continue;
    }
  }

  const linesArray = Array.from(lineMap.values());

  // 3.5) GTX-A 강제 주입 (relation id)
  injectLineFromRelation(elements, [17413295], "GTX-A", (colorMap["GTX-A"] || "#8B1C62"), linesArray);


  // 4) 역 필터링 + 중복 제거 (환승역 병합)
// ===== 역 병합(클러스터링) =====


const THRESH_M = 450; // 필요시 600~800까지 올려보기

// 1) 선로 근처 필터 통과한 후보만 모으기
// 1) 선로 근처 필터 통과한 후보만 모으기 (안전 버전)
const candidates = [];
let sawAnyPointGlobal = false;

for (const s of rawStations) {
  let minD2 = Infinity;
  let sawPoint = false;

  if (linesArray.length > 0) {
    for (const Ln of linesArray) {
      // ⚠️ 여기서 GTX-A를 빼지 마. parseData는 "전체 역 목록"이 목적이라서 부작용 큼.
      for (const seg of Ln.segs) {
        if (!Array.isArray(seg) || seg.length === 0) continue;
        for (const p of seg) {
          sawPoint = true;
          sawAnyPointGlobal = true;
          const d2 = (s.lat - p[0]) ** 2 + (s.lon - p[1]) ** 2;
          if (d2 < minD2) minD2 = d2;
        }
      }
    }
  }

  // ✅ 선로 점을 한 번도 못 봤으면 필터 적용하지 않음 (자동역 몰살 방지)
  if (linesArray.length !== 0 && sawAnyPointGlobal && sawPoint && minD2 >= 0.0005) continue;

  candidates.push({ ...s });
}


// 2) key별로 묶기
const groups = new Map();
for (const s of candidates) {
  const k = s.key;
  if (!groups.has(k)) groups.set(k, []);
  groups.get(k).push(s);
}

// 3) 각 key 그룹에서 거리 기준 클러스터링 → 클러스터마다 1개로 압축
const dedup = [];
for (const [key, arr] of groups.entries()) {
  if (arr.length === 1) {
    dedup.push(arr[0]);
    continue;
  }

  const used = new Array(arr.length).fill(false);

  for (let i = 0; i < arr.length; i++) {
    if (used[i]) continue;
    used[i] = true;

    const q = [i];
    const comp = [arr[i]];

    while (q.length) {
      const u = q.pop();
      for (let v = 0; v < arr.length; v++) {
        if (used[v]) continue;
        if (distMeters(arr[u], arr[v]) <= THRESH_M) {
          used[v] = true;
          q.push(v);
          comp.push(arr[v]);
        }
      }
    }

    let lat = 0, lon = 0;
    for (const s of comp) { lat += s.lat; lon += s.lon; }
    lat /= comp.length; lon /= comp.length;

    dedup.push({ ...comp[0], key, lat, lon });
  }
}

function mergeManualStations(base, manual) {
  const out = base.slice();         // ✅ base는 전부 유지
  const TH_M = 300;                 // manual 좌표와 300m 이내면 "그 역"으로 간주(필요시 조절)

  for (const m of (manual || [])) {
    let bestIdx = -1;
    let bestD = Infinity;

    for (let i = 0; i < out.length; i++) {
      const s = out[i];
      if (s.key !== m.key) continue;              // 같은 '역명 key' 후보만 비교
      const d = haversineMeters(s.lat, s.lon, m.lat, m.lon);
      if (d < bestD) { bestD = d; bestIdx = i; }
    }

    if (bestIdx >= 0 && bestD <= TH_M) {
      // ✅ 가장 가까운 1개만 manual로 보정(덮어쓰기)
      out[bestIdx] = { ...out[bestIdx], ...m, _manual: true };
    } else {
      // ✅ 근처에 같은 이름 역이 없으면 새로 추가
      out.push({ ...m, _manual: true });
    }
  }

  return out;
}


const manualStations = [
  { key: normStationKey("초월"), name: "초월", line: "경강선", lat: 37.3736, lon: 127.2995 },
  { key: normStationKey("임학"), name: "임학", line: "인천1호선", lat: 37.5455, lon: 126.7389 },
  { key: normStationKey("박촌"), name: "박촌", line: "인천1호선", lat: 37.5536, lon: 126.7450 },
  { key: normStationKey("박촌"), name: "박촌", line: "인천1호선", lat: 37.5536, lon: 126.7450 },
  { key: normStationKey("양평"), name: "양평", line: "경의·중앙선", lat: 37.4928, lon: 127.4918 },
  { key: normStationKey("신촌"), name: "신촌", line: "경의·중앙선", lat: 37.5597, lon: 126.9423 },
  { key: normStationKey("부천시청"), name: "부천시청", line: "7호선", lat: 37.5046, lon: 126.7639 },

];

const dedup2 = mergeManualStations(dedup, manualStations);
addStopPointsByNearestStation(lineStops, lineStopPoints, dedup2);

const stationsFinal = mergeManualStations(dedup, manualStations);
// DEBUG: 같은 역 이름이 여러 개로 남아있는지 체크
const m = new Map();
for (const s of dedup2) {
  const base = (s.key || "").split("#")[0];
  if (!m.has(base)) m.set(base, []);
  m.get(base).push(s);
}
const dups = [...m.entries()].filter(([k, arr]) => arr.length >= 2);
console.log("DUP STATIONS:", dups.map(([k, arr]) => ({
  key: k,
  n: arr.length,
  pts: arr.map(x => [x.lat, x.lon])
})));
addManualLineStops(lineStops, "GTX-A", [
  "운정중앙","킨텍스","대곡","연신내","서울","삼성"
]);
const lineStopsObj = Object.fromEntries(
  [...lineStops.entries()].map(([k, v]) => [k, [...v]])
);
const EXCLUDED_STATION_NAMES = [
  // 콘솔에서 복사한 key들 넣기
  // 예: "월미공원" -> "월미공원" 키 형태
  "월미문화의거리",
  "월미공원",
  "월미바다",
  "탑승동",
  "제1터미널",
  "제2터미널",
];
const EXCLUDED_STATION_KEYS = new Set(EXCLUDED_STATION_NAMES.map(normStationKey));
const filteredStations = dedup2.filter(s => !EXCLUDED_STATION_KEYS.has(s.key));

return { lines: linesArray, stations: dedup2, lineStops: lineStopsObj };

}


function pickStationsForLine(lineName, allStations, lineSegs, manualByLine) {
  const allow = new Set((manualByLine?.[lineName] || []).map(x => x.key));

  const THRESH_M = 300; // 이건 보조
  const out = [];

  for (const st of allStations) {
    // 1) 화이트리스트가 있으면 그것만 통과
    if (allow.size > 0 && !allow.has(st.key)) continue;

    // 2) (보조) 선로 근접 체크
    if (distanceToLineMeters(st, lineSegs) <= THRESH_M) out.push(st);
  }
  return out;
}
    function sortLineEntries(entries){
      function keyFor(name){const m=name.match(/^(\d+)호선$/);if(m)return{type:'num',val:parseInt(m[1],10)};return{type:'txt',val:name};}
      return entries.sort(([aName],[bName])=>{const A=keyFor(aName),B=keyFor(bName);if(A.type!==B.type)return A.type==='num'?-1:1;if(A.type==='num')return A.val-B.val;return aName.localeCompare(bName,'ko');});
    }

function drawBaseMarkers(stations) {
  const excludeKeys = new Set(
    ["월미공원", "월미문화의거리", "월미바다", "박물관", "탑승동", "제1터미널", "제2터미널"].map(normStationKey) // 필요하면 추가
  );

  const baseIcon = L.divIcon({
    className: 'base-station-marker',
    html: `<div class='station-icon'></div>`,
    iconSize: [12, 12],
    iconAnchor: [6, 6]
  });

  stations.forEach(s => {
    if (excludeKeys.has(s.key)) return; // ✅ 여기서 컷
    L.marker([s.lat, s.lon], {
      icon: baseIcon,
      zIndexOffset: 100
    }).addTo(map);
  });
}
    let subwayData={lines:[],stations:[]};
    const shownStations=new Map();
    let totalStationsCount = 0;
    let matchedStationsCount = 0;
window.lineStats = window.lineStats || {};
const lineStats = window.lineStats;
    function drawLines(lines){
      lines.forEach(Ln=>{
        lineStats[Ln.name]=lineStats[Ln.name]||{total:0,matched:0,color:Ln.color};
        Ln.segs.forEach(seg=>{if(Array.isArray(seg)&&seg.length)L.polyline(seg,{color:Ln.color,weight:6,opacity:0.95,lineCap:'round'}).addTo(map);});
      });
    }
	const STATION_LINE_OVERRIDE = new Map([
  ["천호", { primary: "8호선", also: ["5호선"] }],
  ["강동구청", { primary: "8호선" }],
  // 필요하면 계속 추가
]);
	function nearestLine(lat, lon) {
		let best = { d2: Infinity, color: '#003DA5', name: null };
		  
		  // 데이터가 아직 안 불러와졌으면 기본값 뱉고 튑니다.
		  if (!subwayData || !subwayData.lines) return best;

		  for (const Ln of subwayData.lines) {
			for (const seg of Ln.segs) {
			  for (const p of seg) {
				const d2 = (lat - p[0]) ** 2 + (lon - p[1]) ** 2;
				if (d2 < best.d2) {
				  best = { d2, color: Ln.color, name: Ln.name };
				}
			  }
			}
		  }
		  return best;
}
function nearestLineForStation(station){
  const ov = STATION_LINE_OVERRIDE.get(station.key);
  if (ov?.primary) return ov.primary; // 문자열로 반환
  return nearestLine(station.lat, station.lon).name; // 기존 거리 기반
}
function computeTotals() {
  const data = window.subwayData;
  if (!data) return;

  const ls = data.lineStops || {};

  // total 세팅
  for (const lineName of Object.keys(ls)) {
    const arr = ls[lineName] || [];
    lineStats[lineName] = lineStats[lineName] || { total: 0, matched: 0, color: colorMap[lineName] || "#003DA5" };
    lineStats[lineName].total = arr.length;
    lineStats[lineName].color = colorMap[lineName] || lineStats[lineName].color || "#003DA5";
    if (typeof lineStats[lineName].matched !== "number") lineStats[lineName].matched = 0;
  }

  // lineStops에 없는 잔재 제거
  for (const k of Object.keys(lineStats)) {
    if (!(k in ls)) delete lineStats[k];
  }
  const uniq = new Set();
Object.values(window.subwayData.lineStops || {}).forEach(arr => arr.forEach(k => uniq.add(k)));
totalStationsCount = uniq.size;
}


    /* ------------------------------------------------ */
    /* PC 환경: 사이드바 업데이트 함수 (기존 로직) */
    /* ------------------------------------------------ */
    function updateSidebar(){
      const container=document.getElementById('lineList');
      container.innerHTML='';
      const entries=sortLineEntries(Object.entries(lineStats));
      entries.forEach(([name,s])=>{
        const div=document.createElement('div');
        div.className='line-item';
        // PC 사이드바에서는 발견 역 개수를 표시합니다.
        div.innerHTML=`<div class='line-dot' style='background:${s.color}'></div><div>${name}</div><div class='count'>${s.matched} / ${s.total}</div>`;
        container.appendChild(div);
      });
    }
    
	const MAX_DISTANCE_SQ = 0.000002; // 0.002 * 0.002 = 0.000004 (경위도 제곱 거리)

    function getNearbyLines(lat, lon) {
        const nearbyLines = new Set();
        subwayData.lines.forEach(Ln => {
            let isNearby = false;
            // 노선의 모든 선분(Segments)을 확인합니다.
            for (const seg of Ln.segs) {
                // 선분의 모든 점을 확인합니다.
                for (const p of seg) {
                    const d2 = (lat - p[0]) ** 2 + (lon - p[1]) ** 2;
                    if (d2 < MAX_DISTANCE_SQ) {
                        nearbyLines.add(Ln.name); // 근처에 있으면 해당 노선 이름 추가
                        isNearby = true;
                        break; // 해당 노선은 찾았으니 다음 노선으로 넘어감
                    }
                }
                if (isNearby) break;
            }
        });
        return Array.from(nearbyLines);
    }
function nearbyLinesForStation(station){
  const ov = STATION_LINE_OVERRIDE.get(station.key);
  if (!ov) return getNearbyLines(station.lat, station.lon);

  // primary는 무조건 포함, also는 추가
  const base = new Set(getNearbyLines(station.lat, station.lon));
  base.add(ov.primary);
  (ov.also || []).forEach(x => base.add(x));
  return [...base];
}
    /* ------------------------------------------------ */
    /* 모바일 환경: 대시보드 업데이트 함수 (새로운 로직) */
    /* ------------------------------------------------ */
    function updateDashboard(){
      const container=document.getElementById('lineButtons');
      if (!container) return; // 요소가 없으면(PC 환경이면) 실행하지 않음

      container.innerHTML='';

      // 1. 전체 발견율 계산 및 업데이트
      matchedStationsCount = 0;
      Object.values(lineStats).forEach(s => { matchedStationsCount += s.matched; });

      const totalRateElement = document.getElementById('totalRate');
      const rate = totalStationsCount > 0 ? (matchedStationsCount / totalStationsCount) * 100 : 0;
      if (totalRateElement) totalRateElement.textContent = `${rate.toFixed(1)} %`;

      // 2. 노선 버튼 그룹 생성 (모바일용)
      const entries=sortLineEntries(Object.entries(lineStats));

      const mainLinesDiv = document.createElement('div');
      mainLinesDiv.className = 'line-group main-lines';

      const otherLinesDiv = document.createElement('div');
      otherLinesDiv.className = 'line-group other-lines';

      entries.forEach(([name,s])=>{
        const btn=document.createElement('button');
        btn.className='line-button';
        btn.style.backgroundColor=s.color;

        const isMainLine = name.match(/^(\d+)호선$/) && parseInt(name.match(/^(\d+)호선$/)[1]) <= 9;
        
        if (isMainLine) {
            btn.textContent = name.replace('호선', '');
            mainLinesDiv.appendChild(btn);
        } else {
            btn.textContent = name; 
            otherLinesDiv.appendChild(btn);
        }
      });
      
      container.appendChild(mainLinesDiv);
      container.appendChild(otherLinesDiv);
    }

    /* ------------------------------------------------ */
    /* 통합 업데이트 함수 (환경에 따라 호출) */
    /* ------------------------------------------------ */
    function updateUI(){

        // 화면 너비에 따라 다른 UI 업데이트 함수 호출
        if (window.innerWidth <= 768) {
            updateDashboard();
        } else {
            updateSidebar();
        }
    }
function linesForStationKey(stKey) {
  const data = window.subwayData;
  const out = [];
  const stops = data?.lineStops || {};
  for (const [lineName, keys] of Object.entries(stops)) {
    if (keys.includes(stKey)) out.push(lineName);
  }
  return out;
}

    async function init(){
      try{
	  // ✅ 노선도/검색 결과에서 완전히 제외할 역들 (월미바다열차)
function excludeStationsEverywhere(names) {
  const keys = new Set();
    const excludeKeys = new Set(names.map(normStationKey));
  for (const nm of names) keys.add(normStationKey(nm));

  // 1) 검색 대상(=stations)에서 제거
  window.subwayData.stations = (window.subwayData.stations || []).filter(s => !keys.has(s.key));

  // 2) lineStops(노선별 정차역 목록)에서도 제거 → total/카운트 꼬임 방지
  const ls = window.subwayData.lineStops || {};
  for (const lineName of Object.keys(ls)) {
    ls[lineName] = (ls[lineName] || []).filter(k => !keys.has(k));
  }
  window.subwayData.lineStops = ls;
}
const CACHE_KEY = "v8:" + bbox.join(",");
const { data: raw, fromCache } = await getOverpassWithCache(overpassQuery, { cacheKey: CACHE_KEY });
window.rawOverpass = raw;
console.log("elements:", raw.elements.length);

// ✅ parseData는 한 번만
subwayData = window.subwayData = parseData(raw);

// ✅ 삭제할 역 이름은 '배열'로 따로 둔다
const EXCLUDED_NAMES = ["월미공원", "월미문화의거리", "월미바다", "박물관", "탑승동", "제1터미널", "제2터미널", "천안아산역", "양평레일바이크종점", "총신대입구(이수)"]; 
const excludeKeys = new Set(EXCLUDED_NAMES.map(normStationKey));

// 1) stations(검색/결과)에서 제거
window.subwayData.stations = (window.subwayData.stations || []).filter(
  s => !excludeKeys.has(s.key)
);

// 2) lineStops(노선 총역수/카운트용)에서도 제거
const ls = window.subwayData.lineStops || {};
for (const lineName of Object.keys(ls)) {
  ls[lineName] = (ls[lineName] || []).filter(k => !excludeKeys.has(k));
}
window.subwayData.lineStops = ls;

// 전역 변수도 같은 객체로
subwayData = window.subwayData;

console.log("Parsed Data:", subwayData);

if (subwayData.lines.length === 0) {
  console.warn("노선 데이터가 없심더! BBox나 쿼리를 확인해보이소.");
}

drawLines(subwayData.lines);
computeTotals();
drawBaseMarkers(subwayData.stations);
updateUI();
restoreProgress();
updateUI();		  

// bounds도 동일하게
const bounds = L.latLngBounds([]);
subwayData.lines.forEach(Ln => Ln.segs.forEach(seg => seg.forEach(p => bounds.extend(p))));
if (bounds.isValid()) map.fitBounds(bounds.pad(0.05));
subwayData.lines.forEach(Ln=>Ln.segs.forEach(seg=>seg.forEach(p=>bounds.extend(p)))); 
if(bounds.isValid())map.fitBounds(bounds.pad(0.05)); }
catch(e){alert('초기화 오류: '+e.message);console.error(e);} }

    // ********* 검색 입력 처리 로직 수정 *********
    const inputPC = document.getElementById('stationSearchPC');
    const inputMobile = document.getElementById('stationSearchMobile');
function pickClosestLineNameForStation(st, lineNames) {
  const data = window.subwayData;
  if (!data || !Array.isArray(data.lines) || !lineNames || lineNames.length === 0) return null;

  let bestName = null;
  let bestD2 = Infinity;

  for (const name of lineNames) {
    const Ln = data.lines.find(L => L.name === name);
    if (!Ln) continue;

    for (const seg of (Ln.segs || [])) {
      if (!Array.isArray(seg)) continue;
      for (const p of seg) {
        const d2 = (st.lat - p[0]) ** 2 + (st.lon - p[1]) ** 2;
        if (d2 < bestD2) {
          bestD2 = d2;
          bestName = name;
        }
      }
    }
  }
  return bestName;
}

function linesForStationResolved(st) {
  // 1) key기반(충돌 가능)
  const byKey = linesForStationKey(st.key);

  // 2) 좌표 기반(충돌에 강함)
  const byGeo = nearbyLinesForStation(st);

  // 둘 다 있으면 교집합 우선(동명이역 분리)
  if (byKey.length && byGeo.length) {
    const setGeo = new Set(byGeo);
    const inter = byKey.filter(x => setGeo.has(x));
    if (inter.length) return inter;
  }

  // 하나만 있으면 그걸 사용
  if (byGeo.length) return byGeo;
  if (byKey.length) return byKey;

  // 최후 수단
  const one = nearestLineForStation(st);
  return one ? [one] : [];
}

const searchHandler = (e, inputElement) => {
  if (e.key !== 'Enter') return;

  const data = window.subwayData;
  if (!data || !Array.isArray(data.stations)) {
    alert("데이터가 아직 로드되지 않았습니다.");
    return;
  }

  const input = (inputElement.value || "").replace(/\./g,'·');
  const key = normStationKey(input);
  if (!key) return;

  const foundList = data.stations.filter(s => s.key === key);
  if (foundList.length === 0) {
    alert("정확히 일치하는 역명을 찾을 수 없습니다.");
    return;
  }

  const center = map.getCenter();

  const targets = foundList
    .filter(s => typeof s.lat !== 'undefined' && s.lat !== null)
    .map(s => ({ s, d2: (s.lat - center.lat)**2 + (s.lon - center.lng)**2 }))
    .sort((a, b) => a.d2 - b.d2)
    .map(x => x.s);

  if (targets.length === 0) return;

  for (const st of targets) {
const stationId = `${st.key}@${st.lat.toFixed(6)},${st.lon.toFixed(6)}`;
if (shownStations.has(stationId)) continue;	

	let connectingLines = linesForStationResolved(st);

// primary(색상용) 라인은 “후보 중 실제로 가장 가까운 노선”
const primaryName = pickClosestLineNameForStation(st, connectingLines);

// primary 라인 색을 우선 사용, 없으면 기존 nearestLine
const primaryObj = primaryName ? data.lines.find(L => L.name === primaryName) : null;
const fallbackNearest = nearestLine(st.lat, st.lon);
const markerColor = primaryObj?.color || colorMap[primaryName] || fallbackNearest.color;

// 아이콘에 markerColor 적용
const icon = L.divIcon({
  className: '',
  html: `<div class='station-icon' style='background-color:${markerColor}; border: 2px solid #fff; width:14px; height:14px;'></div>`,
  iconSize: [14, 14],
  iconAnchor: [7, 7]
});


    const marker = L.marker([st.lat, st.lon], { icon, zIndexOffset: 1000 }).addTo(map);
    L.tooltip({ permanent: true, direction: 'top', className: 'label-text' })
      .setLatLng([st.lat, st.lon])
      .setContent(st.name)
      .addTo(map);

    shownStations.set(stationId, marker);

if (connectingLines.length === 0) {
  connectingLines = nearbyLinesForStation(st); // 이미 만들어둔 함수
}

// ✅ 그래도 없으면 최후: nearest 1개만
if (connectingLines.length === 0) {
  const one = nearestLineForStation(st);
  if (one) connectingLines = [one];
}

// (선택) 디버그: 어떤 역이 lineStops에 없었는지 로그
if (!linesForStationKey(st.key).length) {
  console.warn("[lineStops miss]", st.name, st.key, "fallback:", connectingLines);
}

for (const name of connectingLines) {
  if (!name) continue;
  lineStats[name] = lineStats[name] || { total: 0, matched: 0, color: colorMap[name] || '#003DA5' };
  lineStats[name].matched += 1;
}
  }

  updateUI();
saveProgress();
  inputElement.value = '';
  map.panTo([targets[0].lat, targets[0].lon]);
};
    if (inputPC) inputPC.addEventListener('keypress', e => searchHandler(e, inputPC));
    if (inputMobile) inputMobile.addEventListener('keypress', e => searchHandler(e, inputMobile));
    
    // 화면 크기 변경 시 UI 업데이트 (PC-모바일 전환 시)
    window.addEventListener('resize', updateUI);

    init();
  </script>
</body>
</html>
