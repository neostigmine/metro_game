<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>수도권 지하철 (반응형 v8)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    /* ========================================================== */
    /* 1. PC 기본 스타일 (원본 파일의 스타일 유지) */
    /* ========================================================== */
    html, body, #map { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif; overflow: hidden; }

    /* PC용 Topbar (지도 상단 중앙 검색창) */
    .topbar { 
      position: absolute; z-index: 1001; top: .75rem; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,.95); border-radius: 14px; padding: .5rem .75rem;
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif;
      display: flex; gap: .5rem; align-items: center; box-shadow: 0 2px 6px rgba(0,0,0,.06); 
    }
    .topbar input { border: 1px solid #ccc; border-radius: 10px; padding: .35rem .5rem; font-size: 14px; width: 240px; }

    /* PC용 Sidebar (우측 노선 목록) */
    .sidebar { 
      position: absolute; right: 0; top: 0; width: 300px; height: 100%;
      background: rgba(255,255,255,.98); overflow-y: auto; z-index: 1000;
      font-family: system-ui, -apple-system, 'Noto Sans KR', sans-serif;
      padding: .75rem .75rem 1rem; border-left: 1px solid #e5e5e5;
      box-shadow: -4px 0 8px rgba(0,0,0,.04); 
    }
    .sidebar h3 { font-size: 15px; margin: 0 0 .5rem 0; }
    .line-item { display: grid; grid-template-columns: 18px 1fr auto; align-items: center; gap: .5rem; padding: .25rem .25rem; font-size: 13px; border-radius: 8px; }
    .line-item:hover { background: rgba(0,0,0,.035); }
    .line-dot { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #ddd; }
    .count { font-variant-numeric: tabular-nums; color: #333; }
    
    /* 공통 스타일 유지 */
	.station-icon { 
    /* (수정) 기본 마커는 흰색으로 통일하고, 테두리(border)를 회색으로 설정 */
     width: 10px;        /* 마커 크기 축소 */
     height: 10px;       /* 마커 크기 축소 */
     border: 1px solid #999; /* 밝은 회색 테두리 */
     background-color: #fff; /* 배경색은 흰색 */
     border-radius: 50%; 
     box-shadow: 0 0 1px rgba(0,0,0,.4); /* 그림자 약하게 */
	}
	.label-text {background-color: transparent; border: none; box-shadow: none; font-size: 13px; font-weight: 800; color: #111; text-shadow: 0 0 2px #fff, 0 0 4px #fff; white-space: nowrap;}    
	.label-text {background-color: transparent; border: none; box-shadow: none; font-size: 13px; font-weight: 800; color: #111; text-shadow: 0 0 2px #fff, 0 0 4px #fff; white-space: nowrap;}
	.leaflet-tooltip-top.label-text::before,
	.leaflet-tooltip-bottom.label-text::before,
	.leaflet-tooltip-left.label-text::before,
	.leaflet-tooltip-right.label-text::before {
		border: none !important;
	}
    /* ========================================================== */
    /* 2. 모바일 스타일 (Media Query: 화면 너비 768px 이하) */
    /* ========================================================== */
    @media (max-width: 768px) {
      /* PC용 요소 숨김 (또는 위치 변경) */
      .topbar { display: none !important; } /* PC용 상단 중앙 검색창 숨김 */
      .sidebar { display: none !important; } /* PC용 우측 노선 목록 숨김 */

      /* 모바일용 상단 대시보드 */
      .dashboard {
        position: absolute; top: 0; left: 0; right: 0; z-index: 1001;
        background: rgba(255,255,255,1); 
        padding: 10px 10px 5px;
        box-shadow: 0 3px 6px rgba(0,0,0,.1);
      }
      .completion-rate { margin-bottom: 5px; }
      .rate-number { font-size: 24px; font-weight: 800; color: #333; }
      .rate-text { font-size: 16px; font-weight: 500; color: #555; margin-left: 5px; }

      /* 모바일 노선 버튼 */
      .line-buttons {
        display: flex; flex-direction: column; gap: 5px;
        max-height: 200px; overflow-y: auto; padding-bottom: 5px;
      }
      .line-group {
        display: flex; flex-wrap: wrap; gap: 8px;
      }
      .line-button {
        border: none; color: white; font-weight: 700; cursor: pointer; text-align: center;
        transition: opacity 0.2s;
        box-shadow: 0 1px 3px rgba(0,0,0,.15);
      }
      .main-lines .line-button {
        width: 38px; height: 38px; border-radius: 50%;
        font-size: 16px; line-height: 38px; padding: 0;
      }
      .other-lines .line-button {
        border-radius: 20px; font-size: 12px; padding: 6px 12px; min-width: 60px;
      }
      
      /* 모바일용 검색창 (대시보드 아래) */
      .search-box {
          position: absolute;
          top: 260px; /* **이 값은 모바일 대시보드의 예상 높이(약 170~200px)에 맞춰 조정** */
          left: 15px;
          right: 15px;
          display: flex; /* Flex로 변경 */
          background-color: white;
          border-radius: 10px;
          padding: 5px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.25);
          z-index: 10003; 
      }
      .station-input {
          flex: 1; border: none; padding: 10px 15px; font-size: 16px; outline: none;
      }
      .options-button {
          background: none; border: none; font-size: 20px; padding: 0 10px; color: #888; cursor: pointer;
      }
    }
    
    /* 기본적으로 모바일 UI는 숨김 처리 (PC에서 보이지 않도록) */
    .dashboard, .search-box {
        display: none; 
    }
    /* 단, 모바일 뷰에서는 보이도록 설정 */
    @media (max-width: 768px) {
        .dashboard, .search-box {
            display: block; /* 모바일에서 다시 보이게 함 */
        }
        /* search-box는 flex로 설정해야 내부 요소가 정렬됨 */
        .search-box {
            display: flex;
        }
    }

  </style>
</head>
<body>
  <div id="map"></div>

  <div class="topbar">
    <strong>수도권 지하철</strong>
    <input type="text" id="stationSearchPC" placeholder="역 이름을 입력" />
  </div>
  
  <div class="sidebar">
    <h3>노선 목록</h3>
    <div id="lineList"></div>
  </div>

  <div class="dashboard">
    <div class="completion-rate">
        <span class="rate-number" id="totalRate">0.0 %</span>
        <span class="rate-text">역 발견됨</span>
    </div>
    <div class="line-buttons" id="lineButtons">
        </div>
  </div>

  <div class="search-box">
    <input type="text" id="stationSearchMobile" placeholder="역 이름을 입력" class="station-input" />
    <button class="options-button">⋮</button>
  </div>


  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
	const MANUAL_STATIONS = [
  {
    id: "manual:gyeonggang:chowol",
    name: "초월",
    line: "경강선",
    lat: 37.37,
    lon: 127.29,
  },
];
    // 노선 색상, toCanonicalLine, normStationKey, fetchOverpass, parseData, sortLineEntries, drawLines, nearestLine, computeTotals 함수는 동일하게 유지
    const map = L.map('map', {
    renderer: L.canvas() // 이 한 줄이 랙을 엄청나게 줄여줍니다!
	}).setView([37.56, 126.98], 11);
	
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

	const bbox = [36.7, 126.4, 38.3, 127.9];
const overpassQuery = `[out:json][timeout:300];
(
  relation["type"="route"]["route"~"^(subway|metro|light_rail|tram|monorail|train|railway)$"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]})
    ->.routes;


relation(17413295)->.gtxa;
(.gtxa; >>;);

  way(r.routes);


  way["railway"~"^(subway|light_rail|monorail|tram|metro)$"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  way["railway"~"^(subway|light_rail|monorail|tram|metro|rail)$"]
    ["service"~"^(subway|metro|urban|commuter|high_speed)$"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  node["railway"~"^(station|halt|tram_stop)$"]["amenity"!="bus_station"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

  node["public_transport"="stop_position"]
    ["railway"~"^(stop|station|halt|tram_stop|rail)$"]
    ["amenity"!="bus_station"]
    (${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
	way["railway"~"^(station|halt)$"]["amenity"!="bus_station"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
relation["public_transport"="stop_area"]["amenity"!="bus_station"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});
relation["public_transport"="station"]["amenity"!="bus_station"](${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]});

);
out body;
>;
out geom;`



    const colorMap = {
      "1호선": "#0052A4","2호선": "#00A84D","3호선": "#EF7C1E","4호선": "#00A2D1","5호선": "#A664A3",
      "6호선": "#9E4510","7호선": "#5D6519","8호선": "#D6406A","9호선": "#8E764B",
      "수인·분당선": "#E0A134","경의·중앙선": "#2ABFD0","공항철도": "#006D9D","신분당선": "#BB1834",
      "경강선": "#003DA5","경춘선": "#0C8E72","서해선": "#81A914",
      "김포골드라인": "#A17800","의정부경전철": "#FDA600","용인경전철": "#509F22","우이신설선": "#B0CE18",
      "신림선": "#6789CA","인천1호선": "#6E98BB","인천2호선": "#ED8B00", "GTX-A":"#9A6292",
    };
	
function toCanonicalLine(raw=""){
      let n = (raw||"").toString().normalize("NFKC");
      // 잡다한 수식어 제거
      n = n.replace(/:.*/g, "").replace(/\(.*?\)/g, "").replace(/내선|외선|상행|하행|상선|하선|inbound|outbound/gi, "").replace(/[·\.‧∙・․]/g, "·").replace(/\s+/g, " ").trim();
      n = n.replace(/(성수\s*지선|신설\s*지선|지선)/g, "").replace(/(급행|익스프레스|express)/ig, "").replace(/(셔틀|셔틀트레인|shuttle)/ig, "").replace(/(직통|직통열차|direct)/ig, "").replace(/계통/g, "").replace(/\s+/g, " ").trim();
      n = n.replace(/^수도권 ?전철\s*/g, "").replace(/^서울 ?(지하철|경전철)\s*/g, "").replace(/^인천국제공항철도\s*/g, "공항철도 ").trim();
      
      // [필터링] KTX, SRT, 일반 열차 등은 지도에 안 그리기 위해 빈 값 리턴
      if (/KTX|SRT|새마을|무궁화|누리로|ITX|청춘|가라판|화물|바다열차/.test(n)) return "";
if (/GTX\s*-?\s*A/i.test(n) || /광역급행철도\s*A/i.test(n) || n === "A노선" || n.includes("GTX A")) {
    return "GTX-A";
  }   if (/^신분당선/.test(n)) return "신분당선";
      if (/^1호선/.test(n) || /\b1\s*호선\b/.test(n) || /^(경인선|경원선|장항선)/.test(n)) return "1호선";
      if (/^2호선/.test(n) || /\b2\s*호선\b/.test(n)) return "2호선";
      // [핵심] 일산선 잡아서 3호선으로 편입
      if (/^3호선/.test(n) || /\b3\s*호선\b/.test(n) || /일산선/.test(n)) return "3호선"; 
      if (/^4호선/.test(n) || /\b4\s*호선\b/.test(n) || /^(과천선|안산선)/.test(n)) return "4호선";
      if (/^5호선/.test(n) || /\b5\s*호선\b/.test(n)) return "5호선";
      if (/^6호선/.test(n) || /\b6\s*호선\b/.test(n)) return "6호선";
      if (/^7호선/.test(n) || /\b7\s*호선\b/.test(n)) return "7호선";
      if (/^8호선/.test(n) || /\b8\s*호선\b/.test(n)) return "8호선";
      if (/^9호선/.test(n) || /\b9\s*호선\b/.test(n)) return "9호선";

      if (/^(수인.?분당선|분당선|수인선)$/.test(n)) return "수인·분당선";
      if (/(경의.?중앙선|경의선|중앙선)/.test(n)) return "경의·중앙선";
      if (/인천국제공항|AREX|공항철도/i.test(n)) return "공항철도";
      if (/경춘선/.test(n)) return "경춘선";
      if (/경강선/.test(n)) return "경강선";
      if (/서해선/.test(n)) return "서해선";
      if (/김포골드/.test(n)) return "김포골드라인";
      if (/의정부/.test(n)) return "의정부경전철";
      if (/용인|에버라인/.test(n)) return "용인경전철";
      if (/우이신설/.test(n)) return "우이신설선";
      if (/신림/.test(n)) return "신림선";
      if (/인천.?1호선|인천 도시철도 1호선/.test(n)) return "인천1호선";
      if (/인천.?2호선|인천 도시철도 2호선/.test(n)) return "인천2호선";
// GTX-A 인식 로직 강화
  if (/GTX\s*-?\s*A/i.test(n) || /수도권\s?광역급행철도\s?A/i.test(n)) return "GTX-A";
  // 위 목록에 없으면(예: KTX 노선명 등) 그리지 않음
      return "";
    }
    function normStationKey(s=""){
      return s.trim().normalize('NFKC').replace(/[\(\)\[\]{}]/g,'').replace(/\s+/g,'').replace(/[·\.‧∙・․]/g,'·').replace(/역$/,'').toLowerCase();
    }
async function fetchOverpass(overpassQuery) {
  const url = "https://overpass-api.de/api/interpreter";

  let res, text;
  try {
    res = await fetch(url, { method: "POST", body: overpassQuery });
    text = await res.text();
  } catch (err) {
    console.error("Overpass fetch failed:", err);
    throw err;
  }

  console.log("OVERPASS status:", res.status);
  console.log("OVERPASS head:", text.slice(0, 600));

  if (!res.ok) {
    throw new Error(`Overpass HTTP ${res.status}`);
  }

  let data;
  try {
    data = JSON.parse(text);
  } catch (e) {
    throw new Error("Overpass returned non-JSON (query parse error / HTML error). See console OVERPASS head.");
  }

  if (!data || !Array.isArray(data.elements)) {
    throw new Error("Overpass JSON missing 'elements'. See console.");
  }

  return data;
}

      const wayMap = new Map();
	
function injectLineFromRelation(elements, relationIds, forcedName, forcedColor, linesArray) {
  const waysById = new Map();
  for (const el of elements) {
    if (el.type === "way" && Array.isArray(el.geometry) && el.geometry.length >= 2) {
      waysById.set(el.id, el.geometry.map(p => [p.lat, p.lon]));
    }
  }

  const relSet = new Set(relationIds);

  const segs = [];
  for (const el of elements) {
    if (el.type === "relation" && relSet.has(el.id) && Array.isArray(el.members)) {
      for (const m of el.members) {
        if (m.type === "way") {
          const g = waysById.get(m.ref);
          if (g && g.length >= 2) segs.push(g);
        }
      }
    }
  }

  if (segs.length === 0) return false;
  linesArray.push({ name: forcedName, color: forcedColor, segs });
  return true;
}

function parseData(data) {
  const elements = data.elements || [];

  const wayMap = new Map();
  const lineMap = new Map();
  const rawStations = [];
  const usedWayIds = new Set();

  // 1) 선로 좌표 수집
  for (const el of elements) {
    if (el.type === "way" && Array.isArray(el.geometry)) {
      wayMap.set(el.id, el.geometry.map(p => [p.lat, p.lon]));
    }
  }

  // 2) 노선(Relation) 처리
  for (const el of elements) {
    const t = el.tags || {};
    const r = (t.route || "");

    if (el.type === "relation" && t.type === "route" &&
        /^(subway|metro|light_rail|tram|monorail|train|railway)$/.test(r)) {

      const raw = t["name:ko"] || t.name || t.ref || "";
      const name = toCanonicalLine(raw);
      if (!name) continue;

      const color = colorMap[name] || t.colour || t.color || "#003DA5";
      if (!lineMap.has(name)) lineMap.set(name, { name, color, segs: [] });

      if (Array.isArray(el.members)) {
        for (const m of el.members) {
          if (m.type === "way" && wayMap.has(m.ref)) {
            lineMap.get(name).segs.push(wayMap.get(m.ref));
            usedWayIds.add(m.ref);
          }
        }
      }
    }

    // 2-1) 역 정보 수집 (node)
    if (el.type === "node" && (t.railway === "station" || t.public_transport === "station")) {
      const n = t["name:ko"] || t.name || "";
      if (n && n !== "원릉") rawStations.push({ name: n, key: normStationKey(n), lat: el.lat, lon: el.lon });
    }

    // 2-2) 역 정보 수집 (way: station, out center 필요)
    if (el.type === "way" && t.railway === "station" && el.center) {
      const n = t["name:ko"] || t.name || "";
      if (n && n !== "원릉") rawStations.push({ name: n, key: normStationKey(n), lat: el.center.lat, lon: el.center.lon });
    }

    // 2-3) 역 정보 수집 (relation: stop_area/station, out center 필요)
if (el.type === "relation" && t.public_transport === "stop_area" && el.center) {
  const n = t["name:ko"] || t.name || "";
  if (n && n !== "원릉") stopAreas.push({ name: n, key: normStationKey(n), lat: el.center.lat, lon: el.center.lon });
}

  }

  // 3) 왕따 선로 구제
  for (const el of elements) {
    if (el.type === "way" && wayMap.has(el.id) && !usedWayIds.has(el.id)) {
      const t = el.tags || {};
      const isRailway = /^(subway|light_rail|metro|monorail|rail|train)$/.test(t.railway || "");
      if (!isRailway) continue;

      const raw = t["name:ko"] || t.name || t.ref || "";
      const name = toCanonicalLine(raw);
      if (name && lineMap.has(name)) {
        lineMap.get(name).segs.push(wayMap.get(el.id));
        usedWayIds.add(el.id);
      }
    }
  }

  const linesArray = Array.from(lineMap.values());

  // 3.5) GTX-A 강제 주입 (relation id)
  injectLineFromRelation(elements, [17413295], "GTX-A", (colorMap["GTX-A"] || "#8B1C62"), linesArray);

  // 4) 역 필터링 + 중복 제거
  const seen = new Set();
  const dedup = [];

  for (const s of rawStations) {
    const uniq = `${s.key}@${s.lat.toFixed(5)},${s.lon.toFixed(5)}`;
    if (seen.has(uniq)) continue;

    let minD2 = Infinity;
    if (linesArray.length > 0) {
      for (const Ln of linesArray) {
        for (const seg of Ln.segs) {
          for (const p of seg) {
            const d2 = (s.lat - p[0]) ** 2 + (s.lon - p[1]) ** 2;
            if (d2 < minD2) minD2 = d2;
          }
        }
      }
    }

    if (linesArray.length === 0 || minD2 < 0.0005) {
      seen.add(uniq);
      dedup.push(s);
    }
  }

  // 5) 수동 역 추가 (seen 키 규칙 동일하게)
  const manualStations = [
    { key: normStationKey("초월"), name: "초월", line: "경강선", lat: 37.3736, lon: 127.2995 },
    { key: normStationKey("임학"), name: "임학", line: "인천1호선", lat: 37.5455, lon: 126.7389 },
    { key: normStationKey("박촌"), name: "박촌", line: "인천1호선", lat: 37.5536, lon: 126.7450 },
  ];

  for (const m of manualStations) {
const uniq = m.key;
    if (!seen.has(uniq)) {
      seen.add(uniq);
      dedup.push(m);
    }
  }

  return { lines: linesArray, stations: dedup };
}


    function sortLineEntries(entries){
      function keyFor(name){const m=name.match(/^(\d+)호선$/);if(m)return{type:'num',val:parseInt(m[1],10)};return{type:'txt',val:name};}
      return entries.sort(([aName],[bName])=>{const A=keyFor(aName),B=keyFor(bName);if(A.type!==B.type)return A.type==='num'?-1:1;if(A.type==='num')return A.val-B.val;return aName.localeCompare(bName,'ko');});
    }

	function drawBaseMarkers(stations) {
        // 흰색 기본 마커 아이콘 정의 (CSS에서 흰색으로 정의했기 때문에 별도 style 지정 불필요)
        const baseIcon = L.divIcon({
            className: 'base-station-marker',
            html: `<div class='station-icon'></div>`,
            iconSize: [12, 12],      /* 크기는 CSS의 10px + 테두리 1px에 맞게 */
            iconAnchor: [6, 6]       /* 중앙 정렬 */
        });

        stations.forEach(s => {
            // 마커를 추가하지만, 나중에 검색으로 발견한 마커(노선색 마커)와 겹치지 않도록
            // zIndexOffset을 낮게 설정합니다.
            L.marker([s.lat, s.lon], { 
                icon: baseIcon,
                zIndexOffset: 100 // 검색 마커보다 낮게 설정
            }).addTo(map);
        });
    }
    let subwayData={lines:[],stations:[]};
    const shownStations=new Map(), lineStats={};
    let totalStationsCount = 0;
    let matchedStationsCount = 0;

    function drawLines(lines){
      lines.forEach(Ln=>{
        lineStats[Ln.name]=lineStats[Ln.name]||{total:0,matched:0,color:Ln.color};
        Ln.segs.forEach(seg=>{if(Array.isArray(seg)&&seg.length)L.polyline(seg,{color:Ln.color,weight:6,opacity:0.95,lineCap:'round'}).addTo(map);});
      });
    }
	const STATION_LINE_OVERRIDE = new Map([
  ["천호", { primary: "8호선", also: ["5호선"] }],
  ["강동구청", { primary: "8호선" }],
  // 필요하면 계속 추가
]);
	function nearestLine(lat, lon) {
		let best = { d2: Infinity, color: '#003DA5', name: null };
		  
		  // 데이터가 아직 안 불러와졌으면 기본값 뱉고 튑니다.
		  if (!subwayData || !subwayData.lines) return best;

		  for (const Ln of subwayData.lines) {
			for (const seg of Ln.segs) {
			  for (const p of seg) {
				const d2 = (lat - p[0]) ** 2 + (lon - p[1]) ** 2;
				if (d2 < best.d2) {
				  best = { d2, color: Ln.color, name: Ln.name };
				}
			  }
			}
		  }
		  return best;
}
function nearestLineForStation(station){
  const ov = STATION_LINE_OVERRIDE.get(station.key);
  if (ov?.primary) return ov.primary; // 문자열로 반환
  return nearestLine(station.lat, station.lon).name; // 기존 거리 기반
}
	function computeTotals(){
	  // 모든 노선의 total 초기화
	  Object.keys(lineStats).forEach(name => {
		  lineStats[name].total = 0;
	  });

	  totalStationsCount = subwayData.stations.length; // 중복 없는 전체 고유 역 개수

	  subwayData.stations.forEach(s => {
		// 해당 역이 반경 내에 포함된 모든 노선을 찾습니다.
		const nearbyLines = getNearbyLines(s.lat, s.lon); 
		
		nearbyLines.forEach(lineName => {
		  if (lineStats[lineName]) {
			lineStats[lineName].total += 1; // 우이신설선 포함 모든 해당 노선의 total 증가
		  }
		});
	  });
	}

    /* ------------------------------------------------ */
    /* PC 환경: 사이드바 업데이트 함수 (기존 로직) */
    /* ------------------------------------------------ */
    function updateSidebar(){
      const container=document.getElementById('lineList');
      container.innerHTML='';
      const entries=sortLineEntries(Object.entries(lineStats));
      entries.forEach(([name,s])=>{
        const div=document.createElement('div');
        div.className='line-item';
        // PC 사이드바에서는 발견 역 개수를 표시합니다.
        div.innerHTML=`<div class='line-dot' style='background:${s.color}'></div><div>${name}</div><div class='count'>${s.matched} / ${s.total}</div>`;
        container.appendChild(div);
      });
    }
    
	const MAX_DISTANCE_SQ = 0.000004; // 0.002 * 0.002 = 0.000004 (경위도 제곱 거리)

    function getNearbyLines(lat, lon) {
        const nearbyLines = new Set();
        subwayData.lines.forEach(Ln => {
            let isNearby = false;
            // 노선의 모든 선분(Segments)을 확인합니다.
            for (const seg of Ln.segs) {
                // 선분의 모든 점을 확인합니다.
                for (const p of seg) {
                    const d2 = (lat - p[0]) ** 2 + (lon - p[1]) ** 2;
                    if (d2 < MAX_DISTANCE_SQ) {
                        nearbyLines.add(Ln.name); // 근처에 있으면 해당 노선 이름 추가
                        isNearby = true;
                        break; // 해당 노선은 찾았으니 다음 노선으로 넘어감
                    }
                }
                if (isNearby) break;
            }
        });
        return Array.from(nearbyLines);
    }
function nearbyLinesForStation(station){
  const ov = STATION_LINE_OVERRIDE.get(station.key);
  if (!ov) return getNearbyLines(station.lat, station.lon);

  // primary는 무조건 포함, also는 추가
  const base = new Set(getNearbyLines(station.lat, station.lon));
  base.add(ov.primary);
  (ov.also || []).forEach(x => base.add(x));
  return [...base];
}
    /* ------------------------------------------------ */
    /* 모바일 환경: 대시보드 업데이트 함수 (새로운 로직) */
    /* ------------------------------------------------ */
    function updateDashboard(){
      const container=document.getElementById('lineButtons');
      if (!container) return; // 요소가 없으면(PC 환경이면) 실행하지 않음

      container.innerHTML='';

      // 1. 전체 발견율 계산 및 업데이트
      matchedStationsCount = 0;
      Object.values(lineStats).forEach(s => { matchedStationsCount += s.matched; });

      const totalRateElement = document.getElementById('totalRate');
      const rate = totalStationsCount > 0 ? (matchedStationsCount / totalStationsCount) * 100 : 0;
      if (totalRateElement) totalRateElement.textContent = `${rate.toFixed(1)} %`;

      // 2. 노선 버튼 그룹 생성 (모바일용)
      const entries=sortLineEntries(Object.entries(lineStats));

      const mainLinesDiv = document.createElement('div');
      mainLinesDiv.className = 'line-group main-lines';

      const otherLinesDiv = document.createElement('div');
      otherLinesDiv.className = 'line-group other-lines';

      entries.forEach(([name,s])=>{
        const btn=document.createElement('button');
        btn.className='line-button';
        btn.style.backgroundColor=s.color;

        const isMainLine = name.match(/^(\d+)호선$/) && parseInt(name.match(/^(\d+)호선$/)[1]) <= 9;
        
        if (isMainLine) {
            btn.textContent = name.replace('호선', '');
            mainLinesDiv.appendChild(btn);
        } else {
            btn.textContent = name; 
            otherLinesDiv.appendChild(btn);
        }
      });
      
      container.appendChild(mainLinesDiv);
      container.appendChild(otherLinesDiv);
    }

    /* ------------------------------------------------ */
    /* 통합 업데이트 함수 (환경에 따라 호출) */
    /* ------------------------------------------------ */
    function updateUI(){
        // 화면 너비에 따라 다른 UI 업데이트 함수 호출
        if (window.innerWidth <= 768) {
            updateDashboard();
        } else {
            updateSidebar();
        }
    }


    async function init(){
      try{
const raw = await fetchOverpass(overpassQuery);
console.log("elements:", raw.elements.length);

        subwayData=parseData(raw);
		window.subwayData = subwayData;
		window.rawOverpass = raw;
		console.log("Parsed Data:", subwayData); // 파싱 잘 됐나 확인용
		if (subwayData.lines.length === 0) {
       console.warn("노선 데이터가 없심더! BBox나 쿼리를 확인해보이소.");
    }
        drawLines(subwayData.lines);
        computeTotals(); 
		drawBaseMarkers(subwayData.stations);
        updateUI(); // 초기 UI 업데이트 (반응형)
        
        const bounds=L.latLngBounds([]);
        subwayData.lines.forEach(Ln=>Ln.segs.forEach(seg=>seg.forEach(p=>bounds.extend(p))));
        if(bounds.isValid())map.fitBounds(bounds.pad(0.05));
      }catch(e){alert('초기화 오류: '+e.message);console.error(e);}
    }

    // ********* 검색 입력 처리 로직 수정 *********
    const inputPC = document.getElementById('stationSearchPC');
    const inputMobile = document.getElementById('stationSearchMobile');
    
    const searchHandler = (e, inputElement) => {
      if(e.key==='Enter'){
        const key=normStationKey(inputElement.value.replace(/\./g,'·'));
        if(!key)return;
const foundList = subwayData.stations.filter(s => s.key === key);
if (foundList.length === 0) {
  alert('정확히 일치하는 역명을 찾을 수 없습니다.');
  return;
}

const center = map.getCenter();

const targets = foundList
  .filter(s => typeof s.lat !== 'undefined' && s.lat !== null)
  .map(s => ({ s, d2: (s.lat - center.lat)**2 + (s.lon - center.lng)**2 }))
  .sort((a, b) => a.d2 - b.d2)
  .map(x => x.s);

if (targets.length === 0) return;

for (const st of targets) {
  const stationId = `${st.lat.toFixed(5)}-${st.lon.toFixed(5)}`;

  if (!shownStations.has(stationId)) {
    const nearest = nearestLine(st.lat, st.lon);
    const connectingLines = getNearbyLines(st.lat, st.lon);

    const icon = L.divIcon({
      className: '',
      html: `<div class='station-icon' style='background-color:${nearest.color}; border: 2px solid #fff; width:14px; height:14px;'></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    });

    const m = L.marker([st.lat, st.lon], { icon, zIndexOffset: 1000 }).addTo(map);
    L.tooltip({ permanent: true, direction: 'top', className: 'label-text' })
      .setLatLng([st.lat, st.lon])
      .setContent(st.name)
      .addTo(map);

    shownStations.set(stationId, m);

    connectingLines.forEach(name => {
      if (name) {
        lineStats[name] = lineStats[name] || { total: 0, matched: 0, color: colorMap[name] || '#003DA5' };
        lineStats[name].matched += 1;
      }
    });
  }
}

updateUI();

inputElement.value = '';
map.panTo([targets[0].lat, targets[0].lon]);

// 이동은 “가장 가까운 것”으로만
const first = targets[0];
inputElement.value = '';
map.panTo([first.lat, first.lon]);
        }
        inputElement.value='';map.panTo([found.lat,found.lon]);
      };

    if (inputPC) inputPC.addEventListener('keypress', e => searchHandler(e, inputPC));
    if (inputMobile) inputMobile.addEventListener('keypress', e => searchHandler(e, inputMobile));
    
    // 화면 크기 변경 시 UI 업데이트 (PC-모바일 전환 시)
    window.addEventListener('resize', updateUI);

    init();
  </script>
</body>
</html>
